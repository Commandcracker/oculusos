--[[
MIT License

Copyright (c) 2019 SiliconSloth

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
]]
sha256={}sha256.mod32=2^32;sha256.band=bit32 and bit32.band or bit.band;sha256.bnot=bit32 and bit32.bnot or bit.bnot;sha256.bxor=bit32 and bit32.bxor or bit.bxor;sha256.blshift=bit32 and bit32.lshift or bit.blshift;sha256.upack=unpack;sha256.rrotate=function(a,b)local c=a/2^b;local d=c%1;return c-d+d*sha256.mod32 end;sha256.brshift=function(e,f)local c=e/2^f;return c-c%1 end;sha256.H={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19}sha256.K={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}sha256.counter=function(g)local h,j=0,0;if 0xFFFFFFFF-h<g then j=j+1;h=g-(0xFFFFFFFF-h)-1 else h=h+g end;return j,h end;sha256.BE_toInt=function(k,i)return sha256.blshift(k[i]or 0,24)+sha256.blshift(k[i+1]or 0,16)+sha256.blshift(k[i+2]or 0,8)+(k[i+3]or 0)end;sha256.preprocess=function(l)local m=#l;local n={}l[#l+1]=0x80;while#l%64~=56 do l[#l+1]=0 end;local o=math.ceil(#l/64)for i=1,o do n[i]={}for p=1,16 do n[i][p]=sha256.BE_toInt(l,1+(i-1)*64+(p-1)*4)end end;n[o][15],n[o][16]=sha256.counter(m*8)return n end;sha256.digestblock=function(q,r)for p=17,64 do local s=q[p-15]local t=sha256.bxor(sha256.bxor(sha256.rrotate(q[p-15],7),sha256.rrotate(q[p-15],18)),sha256.brshift(q[p-15],3))local u=sha256.bxor(sha256.bxor(sha256.rrotate(q[p-2],17),sha256.rrotate(q[p-2],19)),sha256.brshift(q[p-2],10))q[p]=(q[p-16]+t+q[p-7]+u)%sha256.mod32 end;local v,b,w,x,y,d,z,A=sha256.upack(r)for p=1,64 do local B=sha256.bxor(sha256.bxor(sha256.rrotate(y,6),sha256.rrotate(y,11)),sha256.rrotate(y,25))local C=sha256.bxor(sha256.band(y,d),sha256.band(sha256.bnot(y),z))local D=(A+B+C+sha256.K[p]+q[p])%sha256.mod32;local E=sha256.bxor(sha256.bxor(sha256.rrotate(v,2),sha256.rrotate(v,13)),sha256.rrotate(v,22))local F=sha256.bxor(sha256.bxor(sha256.band(v,b),sha256.band(v,w)),sha256.band(b,w))local G=(E+F)%sha256.mod32;A,z,d,y,x,w,b,v=z,d,y,(x+D)%sha256.mod32,w,b,v,(D+G)%sha256.mod32 end;r[1]=(r[1]+v)%sha256.mod32;r[2]=(r[2]+b)%sha256.mod32;r[3]=(r[3]+w)%sha256.mod32;r[4]=(r[4]+x)%sha256.mod32;r[5]=(r[5]+y)%sha256.mod32;r[6]=(r[6]+d)%sha256.mod32;r[7]=(r[7]+z)%sha256.mod32;r[8]=(r[8]+A)%sha256.mod32;return r end;sha256.mt={__tostring=function(v)return string.char(unpack(v))end,__index={toHex=function(self,c)return("%02x"):rep(#self):format(unpack(self))end,isEqual=function(self,H)if type(H)~="table"then return false end;if#self~=#H then return false end;local I=0;for i=1,#self do I=bit32.bor(I,sha256.bxor(self[i],H[i]))end;return I==0 end}}sha256.toBytes=function(H,a)local b={}for i=1,a do b[(i-1)*4+1]=sha256.band(sha256.brshift(H[i],24),0xFF)b[(i-1)*4+2]=sha256.band(sha256.brshift(H[i],16),0xFF)b[(i-1)*4+3]=sha256.band(sha256.brshift(H[i],8),0xFF)b[(i-1)*4+4]=sha256.band(H[i],0xFF)end;return setmetatable(b,sha256.mt)end;sha256.digest=function(l)l=l or""l=type(l)=="string"and{l:byte(1,-1)}or l;l=sha256.preprocess(l)local r={sha256.upack(sha256.H)}for i=1,#l do r=sha256.digestblock(l[i],r)end;return sha256.toBytes(r,8)end;sha256.hmac=function(l,J)local l=type(l)=="table"and{sha256.upack(l)}or{tostring(l):byte(1,-1)}local J=type(J)=="table"and{sha256.upack(J)}or{tostring(J):byte(1,-1)}local K=64;J=#J>K and sha256.digest(J)or J;local L={}local M={}local N={}for i=1,K do L[i]=sha256.bxor(0x36,J[i]or 0)M[i]=sha256.bxor(0x5C,J[i]or 0)end;for i=1,#l do L[K+i]=l[i]end;L=sha256.digest(L)for i=1,K do N[i]=M[i]N[K+i]=L[i]end;return sha256.digest(N)end;sha256.pbkdf2=function(O,P,Q,R)local P=type(P)=="table"and P or{tostring(P):byte(1,-1)}local S=32;local R=R or 32;local T=1;local U={}while R>0 do local V={}local W={sha256.upack(P)}local X=R>S and S or R;W[#W+1]=sha256.band(sha256.brshift(T,24),0xFF)W[#W+1]=sha256.band(sha256.brshift(T,16),0xFF)W[#W+1]=sha256.band(sha256.brshift(T,8),0xFF)W[#W+1]=sha256.band(T,0xFF)for p=1,Q do W=sha256.hmac(W,O)for Y=1,X do V[Y]=sha256.bxor(W[Y],V[Y]or 0)end;if p%200==0 then os.queueEvent("PBKDF2",p)coroutine.yield("PBKDF2")end end;R=R-X;T=T+1;for Y=1,X do U[#U+1]=V[Y]end end;return setmetatable(U,sha256.mt)end;rsaCrypt={}rsaCrypt.fl=function(Z)if Z<0 then return math.ceil(Z)+0 else return math.floor(Z)end end;rsaCrypt.cmod=function(v,b)local Z=v%b;if v<0 and Z>0 then Z=Z-b end;return Z end;rsaCrypt.radix=2^24;rsaCrypt.radix_sqrt=rsaCrypt.fl(math.sqrt(rsaCrypt.radix))rsaCrypt.alloc=function()local _={}setmetatable(_,rsaCrypt.bigintmt)_.comps={}_.sign=1;return _ end;rsaCrypt.clone=function(v)local _=rsaCrypt.alloc()_.sign=v.sign;local w=_.comps;local a0=v.comps;for i=1,#a0 do w[i]=a0[i]end;return _ end;rsaCrypt.normalize=function(_,a1)local w=_.comps;local s;for i=1,#w-1 do s=w[i]if s<0 then w[i+1]=w[i+1]+rsaCrypt.fl(s/rsaCrypt.radix)-1;s=rsaCrypt.cmod(s,rsaCrypt.radix)if s~=0 then w[i]=s+rsaCrypt.radix else w[i]=s;w[i+1]=w[i+1]+1 end end end;if w[#w]<0 then _.sign=-_.sign;for i=1,#w-1 do s=w[i]w[i]=rsaCrypt.radix-s;w[i+1]=w[i+1]+1 end;w[#w]=-w[#w]end;for i=1,#w do s=w[i]if s>rsaCrypt.radix then w[i+1]=(w[i+1]or 0)+rsaCrypt.fl(s/rsaCrypt.radix)w[i]=rsaCrypt.cmod(s,rsaCrypt.radix)end end;if not a1 then for i=#w,2,-1 do if w[i]==0 then w[i]=nil else break end end end;if#w==1 and w[1]==0 and _.sign==-1 then _.sign=1 end end;rsaCrypt.negate=function(v)local _=rsaCrypt.clone(v)_.sign=-_.sign;return _ end;rsaCrypt.compare=function(v,b)local a0,a2=v.comps,b.comps;local a3,k=v.sign,b.sign;if a0==a2 then return 0 elseif a3>k then return 1 elseif a3<k then return-1 elseif#a0>#a2 then return a3 elseif#a0<#a2 then return-a3 end;for i=#a0,1,-1 do if a0[i]>a2[i]then return a3 elseif a0[i]<a2[i]then return-a3 end end;return 0 end;rsaCrypt.lt=function(v,b)return rsaCrypt.compare(v,b)<0 end;rsaCrypt.eq=function(v,b)return rsaCrypt.compare(v,b)==0 end;rsaCrypt.le=function(v,b)return rsaCrypt.compare(v,b)<=0 end;rsaCrypt.addint=function(v,a)local _=rsaCrypt.clone(v)if _.sign==1 then _.comps[1]=_.comps[1]+a else _.comps[1]=_.comps[1]-a end;rsaCrypt.normalize(_)return _ end;rsaCrypt.add=function(v,b)if type(v)=="number"then return rsaCrypt.addint(b,v)elseif type(b)=="number"then return rsaCrypt.addint(v,b)end;local _=rsaCrypt.clone(v)local a4=_.sign==b.sign;local w=_.comps;for i=#w+1,#b.comps do w[i]=0 end;local a2=b.comps;for i=1,#a2 do local s=a2[i]if a4 then w[i]=w[i]+s else w[i]=w[i]-s end end;rsaCrypt.normalize(_)return _ end;rsaCrypt.sub=function(v,b)if type(b)=="number"then return rsaCrypt.addint(v,-b)elseif type(v)=="number"then v=rsaCrypt.bigint(v)end;return rsaCrypt.add(v,rsaCrypt.negate(b))end;rsaCrypt.mulint=function(v,b)local _=rsaCrypt.clone(v)if b<0 then b=-b;_.sign=-_.sign end;local a2=_.comps;for i=1,#a2 do a2[i]=a2[i]*b end;rsaCrypt.normalize(_)return _ end;rsaCrypt.multiply=function(v,b)local _=rsaCrypt.alloc()local w=_.comps;local a0,a2=v.comps,b.comps;for i=1,#a0+#a2 do w[i]=0 end;for i=1,#a0 do for p=1,#a2 do w[i+p-1]=w[i+p-1]+a0[i]*a2[p]end;rsaCrypt.normalize(_,true)end;rsaCrypt.normalize(_)if _~=rsaCrypt.bigint(0)then _.sign=v.sign*b.sign end;return _ end;rsaCrypt.kmul=function(v,b)local a0,a2=v.comps,b.comps;local a5,a6=#v.comps,#b.comps;local _,a7,a8,a9=rsaCrypt.alloc(),rsaCrypt.alloc(),rsaCrypt.alloc(),rsaCrypt.alloc()local aa,ab,ac,ad=_.comps,a7.comps,a8.comps,a9.comps;local a=rsaCrypt.fl((math.max(a5,a6)+1)/2)for i=1,a do aa[i]=i+a<=a5 and a0[i+a]or 0;ab[i]=i<=a5 and a0[i]or 0;ac[i]=i+a<=a6 and a2[i+a]or 0;ad[i]=i<=a6 and a2[i]or 0 end;rsaCrypt.normalize(_)rsaCrypt.normalize(a7)rsaCrypt.normalize(a8)rsaCrypt.normalize(a9)local ae=_*a8;local af=a7*a9;local ag=(_+a7)*(a8+a9)-ae-af;local ah=ag.comps;local ai=ae.comps;local aj=af.comps;for i=1,#ai+a*2 do aj[i]=aj[i]or 0 end;for i=1,#ah do aj[i+a]=aj[i+a]+ah[i]end;for i=1,#ai do aj[i+a*2]=aj[i+a*2]+ai[i]end;af.sign=v.sign*b.sign;rsaCrypt.normalize(af)return af end;rsaCrypt.kthresh=12;rsaCrypt.mul=function(v,b)if type(v)=="number"then return rsaCrypt.mulint(b,v)elseif type(b)=="number"then return rsaCrypt.mulint(v,b)end;if#v.comps<rsaCrypt.kthresh or#b.comps<rsaCrypt.kthresh then return rsaCrypt.multiply(v,b)end;return rsaCrypt.kmul(v,b)end;rsaCrypt.divint=function(ak,al)local _=rsaCrypt.clone(ak)if al<0 then al=-al;_.sign=-_.sign end;local am=0;local w=_.comps;for i=#w,1,-1 do am=am*rsaCrypt.radix+w[i]w[i]=rsaCrypt.fl(am/al)am=rsaCrypt.cmod(am,al)end;rsaCrypt.normalize(_)return _ end;rsaCrypt.multi_divide=function(ak,al)local a=#al.comps;local an=rsaCrypt.divint(ak,al.comps[a])for i=a,#an.comps do an.comps[i-a+1]=an.comps[i]end;for i=#an.comps,#an.comps-a+2,-1 do an.comps[i]=nil end;local ao=an*al-ak;if ao<al then quotient=an else quotient=an-rsaCrypt.multi_divide(ao,al)end;return quotient end;rsaCrypt.multi_divide_wrap=function(ak,al)if al.comps[#al.comps]<rsaCrypt.radix_sqrt then ak=rsaCrypt.mulint(ak,rsaCrypt.radix_sqrt)al=rsaCrypt.mulint(al,rsaCrypt.radix_sqrt)end;return rsaCrypt.multi_divide(ak,al)end;rsaCrypt.div=function(ak,al)if type(al)=="number"then if al==0 then error("divide by 0",2)end;return rsaCrypt.divint(ak,al)elseif type(ak)=="number"then ak=rsaCrypt.bigint(ak)end;local a4=1;local ap=rsaCrypt.compare(al,rsaCrypt.bigint(0))if ap==0 then error("divide by 0",2)elseif ap==-1 then a4=-a4;al=rsaCrypt.negate(al)end;ap=rsaCrypt.compare(ak,rsaCrypt.bigint(0))if ap==0 then return rsaCrypt.bigint(0)elseif ap==-1 then a4=-a4;ak=rsaCrypt.negate(ak)end;ap=rsaCrypt.compare(ak,al)if ap==-1 then return rsaCrypt.bigint(0)elseif ap==0 then return rsaCrypt.bigint(a4)end;local _;if#al.comps==1 then _=rsaCrypt.divint(ak,al.comps[1])else _=rsaCrypt.multi_divide_wrap(ak,al)end;if a4==-1 then _=rsaCrypt.negate(_)end;return _ end;rsaCrypt.intrem=function(_,aq)if aq<0 then aq=-aq end;local ar=1;local am=0;local a2=_.comps;for i=1,#a2 do local s=a2[i]am=rsaCrypt.cmod(am+s*ar,aq)ar=rsaCrypt.cmod(ar*rsaCrypt.radix,aq)end;if _.sign<1 then am=-am end;return am end;rsaCrypt.intmod=function(_,aq)local am=rsaCrypt.intrem(_,aq)if am<0 then am=am+aq end;return am end;rsaCrypt.rem=function(_,aq)if type(aq)=="number"then return rsaCrypt.bigint(rsaCrypt.intrem(_,aq))elseif type(_)=="number"then _=rsaCrypt.bigint(_)end;return _-_/aq*aq end;rsaCrypt.mod=function(v,aq)local _=rsaCrypt.rem(v,aq)if _.sign==-1 then _=_+aq end;return _ end;rsaCrypt.printscale=10000000;rsaCrypt.printscalefmt=string.format("%%.%dd",math.log10(rsaCrypt.printscale))rsaCrypt.makestr=function(_,c)if _>=rsaCrypt.bigint(rsaCrypt.printscale)then rsaCrypt.makestr(rsaCrypt.divint(_,rsaCrypt.printscale),c)end;table.insert(c,string.format(rsaCrypt.printscalefmt,rsaCrypt.intmod(_,rsaCrypt.printscale)))end;rsaCrypt.biginttostring=function(_)local c={}if _<rsaCrypt.bigint(0)then _=rsaCrypt.negate(_)table.insert(c,"-")end;rsaCrypt.makestr(_,c)c=table.concat(c):gsub("^0*","")if c==""then c="0"end;return c end;rsaCrypt.biginttonumber=function(_)return tonumber(rsaCrypt.biginttostring(_))end;rsaCrypt.bigintmt={__add=rsaCrypt.add,__sub=rsaCrypt.sub,__mul=rsaCrypt.mul,__div=rsaCrypt.div,__mod=rsaCrypt.mod,__unm=rsaCrypt.negate,__eq=rsaCrypt.eq,__lt=rsaCrypt.lt,__le=rsaCrypt.le,__tostring=rsaCrypt.biginttostring}rsaCrypt.cache={}rsaCrypt.ncache=0;rsaCrypt.bigint=function(a)if rsaCrypt.cache[a]then return rsaCrypt.cache[a]end;local _;if type(a)=="string"then local as={a:byte(1,-1)}for i=1,#as do as[i]=string.char(as[i])end;local at=1;local a4=1;if as[i]=='-'then a4=-1;at=2 end;_=rsaCrypt.bigint(0)for i=at,#as do _=rsaCrypt.addint(rsaCrypt.mulint(_,10),tonumber(as[i]))end;_=rsaCrypt.mulint(_,a4)else _=rsaCrypt.alloc()_.comps[1]=a;rsaCrypt.normalize(_)end;if rsaCrypt.ncache>100 then rsaCrypt.cache={}rsaCrypt.ncache=0 end;rsaCrypt.cache[a]=_;rsaCrypt.ncache=rsaCrypt.ncache+1;return _ end;rsaCrypt.powersTwo={rsaCrypt.bigint("2"),rsaCrypt.bigint("4"),rsaCrypt.bigint("8"),rsaCrypt.bigint("16"),rsaCrypt.bigint("32"),rsaCrypt.bigint("64"),rsaCrypt.bigint("128"),rsaCrypt.bigint("256"),rsaCrypt.bigint("512"),rsaCrypt.bigint("1024"),rsaCrypt.bigint("2048"),rsaCrypt.bigint("4096"),rsaCrypt.bigint("8192"),rsaCrypt.bigint("16384"),rsaCrypt.bigint("32768"),rsaCrypt.bigint("65536"),rsaCrypt.bigint("131072"),rsaCrypt.bigint("262144"),rsaCrypt.bigint("524288"),rsaCrypt.bigint("1048576"),rsaCrypt.bigint("2097152"),rsaCrypt.bigint("4194304"),rsaCrypt.bigint("8388608"),rsaCrypt.bigint("16777216"),rsaCrypt.bigint("33554432"),rsaCrypt.bigint("67108864"),rsaCrypt.bigint("134217728"),rsaCrypt.bigint("268435456"),rsaCrypt.bigint("536870912"),rsaCrypt.bigint("1073741824"),rsaCrypt.bigint("2147483648"),rsaCrypt.bigint("4294967296"),rsaCrypt.bigint("8589934592"),rsaCrypt.bigint("17179869184"),rsaCrypt.bigint("34359738368"),rsaCrypt.bigint("68719476736"),rsaCrypt.bigint("137438953472"),rsaCrypt.bigint("274877906944"),rsaCrypt.bigint("549755813888"),rsaCrypt.bigint("1099511627776"),rsaCrypt.bigint("2199023255552"),rsaCrypt.bigint("4398046511104"),rsaCrypt.bigint("8796093022208"),rsaCrypt.bigint("17592186044416"),rsaCrypt.bigint("35184372088832"),rsaCrypt.bigint("70368744177664"),rsaCrypt.bigint("140737488355328"),rsaCrypt.bigint("281474976710656"),rsaCrypt.bigint("562949953421312"),rsaCrypt.bigint("1125899906842624"),rsaCrypt.bigint("2251799813685248"),rsaCrypt.bigint("4503599627370496"),rsaCrypt.bigint("9007199254740992"),rsaCrypt.bigint("18014398509481984"),rsaCrypt.bigint("36028797018963968"),rsaCrypt.bigint("72057594037927936"),rsaCrypt.bigint("144115188075855872"),rsaCrypt.bigint("288230376151711744"),rsaCrypt.bigint("576460752303423488"),rsaCrypt.bigint("1152921504606846976"),rsaCrypt.bigint("2305843009213693952"),rsaCrypt.bigint("4611686018427387904"),rsaCrypt.bigint("9223372036854775808"),rsaCrypt.bigint("18446744073709551616"),rsaCrypt.bigint("36893488147419103232"),rsaCrypt.bigint("73786976294838206464"),rsaCrypt.bigint("147573952589676412928"),rsaCrypt.bigint("295147905179352825856"),rsaCrypt.bigint("590295810358705651712"),rsaCrypt.bigint("1180591620717411303424"),rsaCrypt.bigint("2361183241434822606848"),rsaCrypt.bigint("4722366482869645213696"),rsaCrypt.bigint("9444732965739290427392"),rsaCrypt.bigint("18889465931478580854784"),rsaCrypt.bigint("37778931862957161709568"),rsaCrypt.bigint("75557863725914323419136"),rsaCrypt.bigint("151115727451828646838272"),rsaCrypt.bigint("302231454903657293676544"),rsaCrypt.bigint("604462909807314587353088"),rsaCrypt.bigint("1208925819614629174706176"),rsaCrypt.bigint("2417851639229258349412352"),rsaCrypt.bigint("4835703278458516698824704"),rsaCrypt.bigint("9671406556917033397649408"),rsaCrypt.bigint("19342813113834066795298816"),rsaCrypt.bigint("38685626227668133590597632"),rsaCrypt.bigint("77371252455336267181195264"),rsaCrypt.bigint("154742504910672534362390528"),rsaCrypt.bigint("309485009821345068724781056"),rsaCrypt.bigint("618970019642690137449562112"),rsaCrypt.bigint("1237940039285380274899124224"),rsaCrypt.bigint("2475880078570760549798248448"),rsaCrypt.bigint("4951760157141521099596496896"),rsaCrypt.bigint("9903520314283042199192993792"),rsaCrypt.bigint("19807040628566084398385987584"),rsaCrypt.bigint("39614081257132168796771975168"),rsaCrypt.bigint("79228162514264337593543950336"),rsaCrypt.bigint("158456325028528675187087900672"),rsaCrypt.bigint("316912650057057350374175801344"),rsaCrypt.bigint("633825300114114700748351602688"),rsaCrypt.bigint("1267650600228229401496703205376"),rsaCrypt.bigint("2535301200456458802993406410752"),rsaCrypt.bigint("5070602400912917605986812821504"),rsaCrypt.bigint("10141204801825835211973625643008"),rsaCrypt.bigint("20282409603651670423947251286016"),rsaCrypt.bigint("40564819207303340847894502572032"),rsaCrypt.bigint("81129638414606681695789005144064"),rsaCrypt.bigint("162259276829213363391578010288128"),rsaCrypt.bigint("324518553658426726783156020576256"),rsaCrypt.bigint("649037107316853453566312041152512"),rsaCrypt.bigint("1298074214633706907132624082305024"),rsaCrypt.bigint("2596148429267413814265248164610048"),rsaCrypt.bigint("5192296858534827628530496329220096"),rsaCrypt.bigint("10384593717069655257060992658440192"),rsaCrypt.bigint("20769187434139310514121985316880384"),rsaCrypt.bigint("41538374868278621028243970633760768"),rsaCrypt.bigint("83076749736557242056487941267521536"),rsaCrypt.bigint("166153499473114484112975882535043072"),rsaCrypt.bigint("332306998946228968225951765070086144"),rsaCrypt.bigint("664613997892457936451903530140172288"),rsaCrypt.bigint("1329227995784915872903807060280344576"),rsaCrypt.bigint("2658455991569831745807614120560689152"),rsaCrypt.bigint("5316911983139663491615228241121378304"),rsaCrypt.bigint("10633823966279326983230456482242756608"),rsaCrypt.bigint("21267647932558653966460912964485513216"),rsaCrypt.bigint("42535295865117307932921825928971026432"),rsaCrypt.bigint("85070591730234615865843651857942052864"),rsaCrypt.bigint("170141183460469231731687303715884105728"),rsaCrypt.bigint("340282366920938463463374607431768211456"),rsaCrypt.bigint("680564733841876926926749214863536422912"),rsaCrypt.bigint("1361129467683753853853498429727072845824"),rsaCrypt.bigint("2722258935367507707706996859454145691648"),rsaCrypt.bigint("5444517870735015415413993718908291383296"),rsaCrypt.bigint("10889035741470030830827987437816582766592"),rsaCrypt.bigint("21778071482940061661655974875633165533184"),rsaCrypt.bigint("43556142965880123323311949751266331066368"),rsaCrypt.bigint("87112285931760246646623899502532662132736"),rsaCrypt.bigint("174224571863520493293247799005065324265472"),rsaCrypt.bigint("348449143727040986586495598010130648530944"),rsaCrypt.bigint("696898287454081973172991196020261297061888"),rsaCrypt.bigint("1393796574908163946345982392040522594123776"),rsaCrypt.bigint("2787593149816327892691964784081045188247552"),rsaCrypt.bigint("5575186299632655785383929568162090376495104"),rsaCrypt.bigint("11150372599265311570767859136324180752990208"),rsaCrypt.bigint("22300745198530623141535718272648361505980416"),rsaCrypt.bigint("44601490397061246283071436545296723011960832"),rsaCrypt.bigint("89202980794122492566142873090593446023921664"),rsaCrypt.bigint("178405961588244985132285746181186892047843328"),rsaCrypt.bigint("356811923176489970264571492362373784095686656"),rsaCrypt.bigint("713623846352979940529142984724747568191373312"),rsaCrypt.bigint("1427247692705959881058285969449495136382746624"),rsaCrypt.bigint("2854495385411919762116571938898990272765493248"),rsaCrypt.bigint("5708990770823839524233143877797980545530986496"),rsaCrypt.bigint("11417981541647679048466287755595961091061972992"),rsaCrypt.bigint("22835963083295358096932575511191922182123945984"),rsaCrypt.bigint("45671926166590716193865151022383844364247891968"),rsaCrypt.bigint("91343852333181432387730302044767688728495783936"),rsaCrypt.bigint("182687704666362864775460604089535377456991567872"),rsaCrypt.bigint("365375409332725729550921208179070754913983135744"),rsaCrypt.bigint("730750818665451459101842416358141509827966271488"),rsaCrypt.bigint("1461501637330902918203684832716283019655932542976"),rsaCrypt.bigint("2923003274661805836407369665432566039311865085952"),rsaCrypt.bigint("5846006549323611672814739330865132078623730171904"),rsaCrypt.bigint("11692013098647223345629478661730264157247460343808"),rsaCrypt.bigint("23384026197294446691258957323460528314494920687616"),rsaCrypt.bigint("46768052394588893382517914646921056628989841375232"),rsaCrypt.bigint("93536104789177786765035829293842113257979682750464"),rsaCrypt.bigint("187072209578355573530071658587684226515959365500928"),rsaCrypt.bigint("374144419156711147060143317175368453031918731001856"),rsaCrypt.bigint("748288838313422294120286634350736906063837462003712"),rsaCrypt.bigint("1496577676626844588240573268701473812127674924007424"),rsaCrypt.bigint("2993155353253689176481146537402947624255349848014848"),rsaCrypt.bigint("5986310706507378352962293074805895248510699696029696"),rsaCrypt.bigint("11972621413014756705924586149611790497021399392059392"),rsaCrypt.bigint("23945242826029513411849172299223580994042798784118784"),rsaCrypt.bigint("47890485652059026823698344598447161988085597568237568"),rsaCrypt.bigint("95780971304118053647396689196894323976171195136475136"),rsaCrypt.bigint("191561942608236107294793378393788647952342390272950272"),rsaCrypt.bigint("383123885216472214589586756787577295904684780545900544"),rsaCrypt.bigint("766247770432944429179173513575154591809369561091801088"),rsaCrypt.bigint("1532495540865888858358347027150309183618739122183602176"),rsaCrypt.bigint("3064991081731777716716694054300618367237478244367204352"),rsaCrypt.bigint("6129982163463555433433388108601236734474956488734408704"),rsaCrypt.bigint("12259964326927110866866776217202473468949912977468817408"),rsaCrypt.bigint("24519928653854221733733552434404946937899825954937634816"),rsaCrypt.bigint("49039857307708443467467104868809893875799651909875269632"),rsaCrypt.bigint("98079714615416886934934209737619787751599303819750539264"),rsaCrypt.bigint("196159429230833773869868419475239575503198607639501078528"),rsaCrypt.bigint("392318858461667547739736838950479151006397215279002157056"),rsaCrypt.bigint("784637716923335095479473677900958302012794430558004314112"),rsaCrypt.bigint("1569275433846670190958947355801916604025588861116008628224"),rsaCrypt.bigint("3138550867693340381917894711603833208051177722232017256448"),rsaCrypt.bigint("6277101735386680763835789423207666416102355444464034512896"),rsaCrypt.bigint("12554203470773361527671578846415332832204710888928069025792"),rsaCrypt.bigint("25108406941546723055343157692830665664409421777856138051584"),rsaCrypt.bigint("50216813883093446110686315385661331328818843555712276103168"),rsaCrypt.bigint("100433627766186892221372630771322662657637687111424552206336"),rsaCrypt.bigint("200867255532373784442745261542645325315275374222849104412672"),rsaCrypt.bigint("401734511064747568885490523085290650630550748445698208825344"),rsaCrypt.bigint("803469022129495137770981046170581301261101496891396417650688"),rsaCrypt.bigint("1606938044258990275541962092341162602522202993782792835301376"),rsaCrypt.bigint("3213876088517980551083924184682325205044405987565585670602752"),rsaCrypt.bigint("6427752177035961102167848369364650410088811975131171341205504"),rsaCrypt.bigint("12855504354071922204335696738729300820177623950262342682411008"),rsaCrypt.bigint("25711008708143844408671393477458601640355247900524685364822016"),rsaCrypt.bigint("51422017416287688817342786954917203280710495801049370729644032"),rsaCrypt.bigint("102844034832575377634685573909834406561420991602098741459288064"),rsaCrypt.bigint("205688069665150755269371147819668813122841983204197482918576128"),rsaCrypt.bigint("411376139330301510538742295639337626245683966408394965837152256"),rsaCrypt.bigint("822752278660603021077484591278675252491367932816789931674304512"),rsaCrypt.bigint("1645504557321206042154969182557350504982735865633579863348609024"),rsaCrypt.bigint("3291009114642412084309938365114701009965471731267159726697218048"),rsaCrypt.bigint("6582018229284824168619876730229402019930943462534319453394436096"),rsaCrypt.bigint("13164036458569648337239753460458804039861886925068638906788872192"),rsaCrypt.bigint("26328072917139296674479506920917608079723773850137277813577744384"),rsaCrypt.bigint("52656145834278593348959013841835216159447547700274555627155488768"),rsaCrypt.bigint("105312291668557186697918027683670432318895095400549111254310977536"),rsaCrypt.bigint("210624583337114373395836055367340864637790190801098222508621955072"),rsaCrypt.bigint("421249166674228746791672110734681729275580381602196445017243910144"),rsaCrypt.bigint("842498333348457493583344221469363458551160763204392890034487820288"),rsaCrypt.bigint("1684996666696914987166688442938726917102321526408785780068975640576"),rsaCrypt.bigint("3369993333393829974333376885877453834204643052817571560137951281152"),rsaCrypt.bigint("6739986666787659948666753771754907668409286105635143120275902562304"),rsaCrypt.bigint("13479973333575319897333507543509815336818572211270286240551805124608"),rsaCrypt.bigint("26959946667150639794667015087019630673637144422540572481103610249216"),rsaCrypt.bigint("53919893334301279589334030174039261347274288845081144962207220498432"),rsaCrypt.bigint("107839786668602559178668060348078522694548577690162289924414440996864"),rsaCrypt.bigint("215679573337205118357336120696157045389097155380324579848828881993728"),rsaCrypt.bigint("431359146674410236714672241392314090778194310760649159697657763987456"),rsaCrypt.bigint("862718293348820473429344482784628181556388621521298319395315527974912"),rsaCrypt.bigint("1725436586697640946858688965569256363112777243042596638790631055949824"),rsaCrypt.bigint("3450873173395281893717377931138512726225554486085193277581262111899648"),rsaCrypt.bigint("6901746346790563787434755862277025452451108972170386555162524223799296"),rsaCrypt.bigint("13803492693581127574869511724554050904902217944340773110325048447598592"),rsaCrypt.bigint("27606985387162255149739023449108101809804435888681546220650096895197184"),rsaCrypt.bigint("55213970774324510299478046898216203619608871777363092441300193790394368"),rsaCrypt.bigint("110427941548649020598956093796432407239217743554726184882600387580788736"),rsaCrypt.bigint("220855883097298041197912187592864814478435487109452369765200775161577472"),rsaCrypt.bigint("441711766194596082395824375185729628956870974218904739530401550323154944"),rsaCrypt.bigint("883423532389192164791648750371459257913741948437809479060803100646309888"),rsaCrypt.bigint("1766847064778384329583297500742918515827483896875618958121606201292619776"),rsaCrypt.bigint("3533694129556768659166595001485837031654967793751237916243212402585239552"),rsaCrypt.bigint("7067388259113537318333190002971674063309935587502475832486424805170479104"),rsaCrypt.bigint("14134776518227074636666380005943348126619871175004951664972849610340958208"),rsaCrypt.bigint("28269553036454149273332760011886696253239742350009903329945699220681916416"),rsaCrypt.bigint("56539106072908298546665520023773392506479484700019806659891398441363832832"),rsaCrypt.bigint("113078212145816597093331040047546785012958969400039613319782796882727665664"),rsaCrypt.bigint("226156424291633194186662080095093570025917938800079226639565593765455331328"),rsaCrypt.bigint("452312848583266388373324160190187140051835877600158453279131187530910662656"),rsaCrypt.bigint("904625697166532776746648320380374280103671755200316906558262375061821325312"),rsaCrypt.bigint("1809251394333065553493296640760748560207343510400633813116524750123642650624"),rsaCrypt.bigint("3618502788666131106986593281521497120414687020801267626233049500247285301248"),rsaCrypt.bigint("7237005577332262213973186563042994240829374041602535252466099000494570602496"),rsaCrypt.bigint("14474011154664524427946373126085988481658748083205070504932198000989141204992"),rsaCrypt.bigint("28948022309329048855892746252171976963317496166410141009864396001978282409984"),rsaCrypt.bigint("57896044618658097711785492504343953926634992332820282019728792003956564819968"),rsaCrypt.bigint("115792089237316195423570985008687907853269984665640564039457584007913129639936")}rsaCrypt.powersTwo[0]=rsaCrypt.bigint("1")rsaCrypt.bigZero=rsaCrypt.bigint(0)rsaCrypt.bigOne=rsaCrypt.bigint(1)rsaCrypt.numberToBytes=function(au,av,aw)if av>#rsaCrypt.powersTwo then error("Too many bits. Must be <= "..#rsaCrypt.powersTwo..".")end;au=rsaCrypt.bigint(au)local ax={}ax[1]={}for i=av-1,0,-1 do local ay=rsaCrypt.powersTwo[i]local az=au-ay;if ay<=az then return nil end;if az<rsaCrypt.bigZero then if#ax[#ax]>=aw then table.insert(ax,{0})else table.insert(ax[#ax],0)end else au=az;if#ax[#ax]>=aw then table.insert(ax,{1})else table.insert(ax[#ax],1)end end;if au==rsaCrypt.bigint(0)then break end end;local aA={}for aB,aC in pairs(ax)do local aD=0;for Y,aE in pairs(aC)do if aE==1 then aD=aD+2^(aw-Y)end end;table.insert(aA,aD)end;return aA end;rsaCrypt.bytesToNumber=function(aF,av,aw)if av>#rsaCrypt.powersTwo then error("Too many bits. Must be <= "..#rsaCrypt.powersTwo..".")end;if#aF>av/aw then error("Too many bytes to store into the number of bits available. Must be <= "..av/aw..".")end;local aG={}for aB,aH in pairs(aF)do for i=aw-1,0,-1 do if aH-2^i<0 then table.insert(aG,0)else table.insert(aG,1)aH=aH-2^i end end end;local au=rsaCrypt.bigint(0)for i=1,#aG do if aG[i]==1 then au=au+rsaCrypt.powersTwo[av-i]end end;return tostring(au)end;rsaCrypt.encodeBigNumbers=function(aI)for Y,s in pairs(aI)do aI[Y]=tostring(s)end;return aI end;rsaCrypt.stringToBytes=function(aJ)local aK={}for i=1,#aJ do table.insert(aK,string.byte(aJ,i))end;return aK end;rsaCrypt.bytesToString=function(aF)local aJ=""for aB,s in pairs(aF)do aJ=aJ..string.char(s)end;return aJ end;rsaCrypt.modexp=function(aL,aM,aN)local am=1;while true do if aM%2==rsaCrypt.bigOne then am=am*aL%aN end;aM=aM/2;if aM==rsaCrypt.bigZero then break end;aL=aL*aL%aN end;return am end;rsaCrypt.crypt=function(J,aO)local aP;if J.public then aP=rsaCrypt.bigint(J.public)else aP=rsaCrypt.bigint(J.private)end;return tostring(rsaCrypt.modexp(rsaCrypt.bigint(aO),aP,rsaCrypt.bigint(J.shared)))end;rsaKeygen={}rsaKeygen.bigZero=rsaCrypt.bigint(0)rsaKeygen.bigOne=rsaCrypt.bigint(1)rsaKeygen.gcd=function(v,b)if b~=rsaKeygen.bigZero then return rsaKeygen.gcd(b,v%b)else return v end end;rsaKeygen.modexp=function(aL,aM,aN)local am=1;while true do if aM%2==rsaKeygen.bigOne then am=am*aL%aN end;aM=aM/2;if aM==rsaKeygen.bigZero then break end;aL=aL*aL%aN end;return am end;rsaKeygen.bigRandomWithLength=function(aQ,aR)if not aR then aR=999999999 end;local aS=tostring(math.random(100000000,aR))while true do aS=aS..tostring(math.random(100000000,aR))if#aS>=aQ then local aT=aS:sub(1,aQ)if aT:sub(-1,-1)=="2"then return rsaCrypt.bigint(aT:sub(1,-2).."3")elseif aT:sub(-1,-1)=="4"then return rsaCrypt.bigint(aT:sub(1,-2).."5")elseif aT:sub(-1,-1)=="6"then return rsaCrypt.bigint(aT:sub(1,-2).."7")elseif aT:sub(-1,-1)=="8"then return rsaCrypt.bigint(aT:sub(1,-2).."9")elseif aT:sub(-1,-1)=="0"then return rsaCrypt.bigint(aT:sub(1,-2).."1")else return rsaCrypt.bigint(aT)end end end end;rsaKeygen.bigRandom=function(aU,aV)if aV<rsaCrypt.bigint(1000000000)then return rsaCrypt.bigint(math.random(rsaCrypt.biginttonumber(aU),rsaCrypt.biginttonumber(aV)))end;local aW=tostring(aV)local aR=tonumber(tostring(aV):sub(1,9))local aX=#aW-#tostring(aU)if aX==0 then return rsaKeygen.bigRandomWithLength(#aW,aR)end;if#aW>30 then return rsaKeygen.bigRandomWithLength(#aW-1)end;local aY=math.random(1,2^(#aW-1))for i=1,#aW-1 do if aY<=2^i then return rsaKeygen.bigRandomWithLength(i)end end end;rsaKeygen.isPrime=function(a)if type(a)=="number"then a=rsaCrypt.bigint(a)end;if a%2==rsaKeygen.bigZero then return false end;local c,x=0,a-rsaKeygen.bigOne;while x%2==rsaKeygen.bigZero do c,x=c+1,x/2 end;for i=1,3 do local v=rsaKeygen.bigRandom(rsaCrypt.bigint(2),a-2)local Z=rsaKeygen.modexp(v,x,a)if Z~=rsaKeygen.bigOne and Z+1~=a then for p=1,c do Z=rsaKeygen.modexp(Z,rsaCrypt.bigint(2),a)if Z==rsaKeygen.bigOne then return false elseif Z==a-1 then v=rsaKeygen.bigZero;break end end;if v~=rsaKeygen.bigZero then return false end end end;return true end;rsaKeygen.generateLargePrime=function()local i=0;while true do write(".")os.sleep(0.1)local aZ=rsaKeygen.bigRandomWithLength(39)if rsaKeygen.isPrime(aZ)then return aZ end end end;rsaKeygen.generatePQ=function(y)local a_;while true do a_=rsaKeygen.generateLargePrime()if rsaKeygen.gcd(y,a_-1)==rsaKeygen.bigOne then return a_ end end end;rsaKeygen.euclidean=function(v,b)local Z,b0,b1,s=rsaKeygen.bigZero,rsaKeygen.bigOne,rsaKeygen.bigOne,rsaKeygen.bigZero;while v~=rsaKeygen.bigZero do local b2,am=b/v,b%v;local aq,a=Z-b1*b2,b0-s*b2;b,v,Z,b0,b1,s=v,am,b1,s,aq,a end;return b,Z,b0 end;rsaKeygen.modinv=function(v,aq)local b3,Z,b0=rsaKeygen.euclidean(v,aq)if b3~=rsaKeygen.bigOne then return nil else return Z%aq end end;rsaKeygen.generateKeyPair=function()while true do local y=rsaKeygen.generateLargePrime()write("-")sleep(0.1)local b4=rsaKeygen.generatePQ(y)write("-")sleep(0.1)local b2=rsaKeygen.generatePQ(y)write("-")sleep(0.1)local a=b4*b2;local b5=(b4-1)*(b2-1)local x=rsaKeygen.modinv(y,b5)local b6=rsaKeygen.modexp(rsaCrypt.bigint(104328),y,a)local b7=rsaKeygen.modexp(b6,x,a)write("+")sleep(0.1)counter=0;if b7==rsaCrypt.bigint(104328)then counter=0;return{shared=tostring(a),public=tostring(y)},{shared=tostring(a),private=tostring(x)}end end end;isaac={}isaac.toBinary=function(v)local b={}local b8=v;while true do table.insert(b,b8%2)b8=math.floor(b8/2)if b8==0 then break end end;return b end;isaac.fromBinary=function(v)local b9=0;for i=#v,1,-1 do b9=b9*2+v[i]end;return b9 end;isaac.aa=0;isaac.bb=0;isaac.cc=0;isaac.randrsl={}isaac.mm={}isaac.MT={}isaac.index=0;isaac.mtSeeded=false;isaac.mtSeed=math.random(1,2^31-1)isaac.initalize_mt_generator=function(ba)isaac.index=0;isaac.MT[0]=ba;for i=1,623 do local bb=1812433253*bit.bxor(isaac.MT[i-1],bit.brshift(isaac.MT[i-1],30))+i;local b=isaac.toBinary(bb)while#b>32 do table.remove(b,1)end;isaac.MT[i]=isaac.fromBinary(b)end end;isaac.generate_mt=function()for i=0,623 do local b0=bit.band(isaac.MT[i],0x80000000)b0=b0+bit.band(isaac.MT[(i+1)%624],0x7FFFFFFF)isaac.MT[i]=bit.bxor(isaac.MT[(i+397)%624],bit.brshift(b0,1))if b0%2==1 then isaac.MT[i]=bit.bxor(isaac.MT[i],0x9908B0DF)end end end;isaac.extract_mt=function(bc,bd)if isaac.index==0 then isaac.generate_mt()end;local b0=isaac.MT[isaac.index]bc=bc or 0;bd=bd or 2^32-1;b0=bit.bxor(b0,bit.brshift(b0,11))b0=bit.bxor(b0,bit.band(bit.blshift(b0,7),0x9D2C5680))b0=bit.bxor(b0,bit.band(bit.blshift(b0,15),0xEFC60000))b0=bit.bxor(b0,bit.brshift(b0,18))isaac.index=(isaac.index+1)%624;return b0%bd+bc end;isaac.seed_from_mt=function(ba)if ba then isaac.mtSeeded=false;isaac.mtSeed=ba end;if not isaac.mtSeeded or math.random(1,100)==50 then isaac.initalize_mt_generator(isaac.mtSeed)isaac.mtSeeded=true;isaac.mtSeed=isaac.extract_mt()end;for i=1,256 do isaac.randrsl[i]=isaac.extract_mt()end end;isaac.mix=function(v,b,w,x,y,d,z,A)v=v%(2^32-1)b=b%(2^32-1)w=w%(2^32-1)x=x%(2^32-1)y=y%(2^32-1)d=d%(2^32-1)z=z%(2^32-1)A=A%(2^32-1)v=bit.bxor(v,bit.blshift(b,11))x=(x+v)%(2^32-1)b=(b+w)%(2^32-1)b=bit.bxor(b,bit.brshift(w,2))y=(y+b)%(2^32-1)w=(w+x)%(2^32-1)w=bit.bxor(w,bit.blshift(x,8))d=(d+w)%(2^32-1)x=(x+y)%(2^32-1)x=bit.bxor(x,bit.brshift(y,16))z=(z+x)%(2^32-1)y=(y+d)%(2^32-1)y=bit.bxor(y,bit.blshift(d,10))A=(A+y)%(2^32-1)d=(d+z)%(2^32-1)d=bit.bxor(d,bit.brshift(z,4))v=(v+d)%(2^32-1)z=(z+A)%(2^32-1)z=bit.bxor(z,bit.blshift(A,8))b=(b+z)%(2^32-1)A=(A+v)%(2^32-1)A=bit.bxor(A,bit.brshift(v,9))w=(w+A)%(2^32-1)v=(v+b)%(2^32-1)return v,b,w,x,y,d,z,A end;isaac.isaac=function()local Z,b0=0,0;for i=1,256 do Z=isaac.mm[i]if i%4==0 then isaac.aa=bit.bxor(isaac.aa,bit.blshift(isaac.aa,13))elseif i%4==1 then isaac.aa=bit.bxor(isaac.aa,bit.brshift(isaac.aa,6))elseif i%4==2 then isaac.aa=bit.bxor(isaac.aa,bit.blshift(isaac.aa,2))elseif i%4==3 then isaac.aa=bit.bxor(isaac.aa,bit.brshift(isaac.aa,16))end;isaac.aa=(isaac.mm[(i+128)%256+1]+isaac.aa)%(2^32-1)b0=(isaac.mm[bit.brshift(Z,2)%256+1]+isaac.aa+isaac.bb)%(2^32-1)isaac.mm[i]=b0;isaac.bb=(isaac.mm[bit.brshift(b0,10)%256+1]+Z)%(2^32-1)isaac.randrsl[i]=isaac.bb end end;isaac.randinit=function(be)local v,b,w,x,y,d,z,A=0x9e3779b9,0x9e3779b9,0x9e3779b9,0x9e3779b9,0x9e3779b9,0x9e3779b9,0x9e3779b9,0x9e3779b9;isaac.aa=0;isaac.bb=0;isaac.cc=0;for i=1,4 do v,b,w,x,y,d,z,A=isaac.mix(v,b,w,x,y,d,z,A)end;for i=1,256,8 do if be then v=(v+isaac.randrsl[i])%(2^32-1)b=(b+isaac.randrsl[i+1])%(2^32-1)w=(w+isaac.randrsl[i+2])%(2^32-1)x=(b+isaac.randrsl[i+3])%(2^32-1)y=(y+isaac.randrsl[i+4])%(2^32-1)d=(d+isaac.randrsl[i+5])%(2^32-1)z=(z+isaac.randrsl[i+6])%(2^32-1)A=(A+isaac.randrsl[i+7])%(2^32-1)end;v,b,w,x,y,d,z,A=isaac.mix(v,b,w,x,y,d,z,A)isaac.mm[i]=v;isaac.mm[i+1]=b;isaac.mm[i+2]=w;isaac.mm[i+3]=x;isaac.mm[i+4]=y;isaac.mm[i+5]=d;isaac.mm[i+6]=z;isaac.mm[i+7]=A end;if be then for i=1,256,8 do v=(v+isaac.randrsl[i])%(2^32-1)b=(b+isaac.randrsl[i+1])%(2^32-1)w=(w+isaac.randrsl[i+2])%(2^32-1)x=(b+isaac.randrsl[i+3])%(2^32-1)y=(y+isaac.randrsl[i+4])%(2^32-1)d=(d+isaac.randrsl[i+5])%(2^32-1)z=(z+isaac.randrsl[i+6])%(2^32-1)A=(A+isaac.randrsl[i+7])%(2^32-1)v,b,w,x,y,d,z,A=isaac.mix(v,b,w,x,y,d,z,A)isaac.mm[i]=v;isaac.mm[i+1]=b;isaac.mm[i+2]=w;isaac.mm[i+3]=x;isaac.mm[i+4]=y;isaac.mm[i+5]=d;isaac.mm[i+6]=z;isaac.mm[i+7]=A end end;isaac.isaac()randcnt=256 end;isaac.generate_isaac=function(bf)isaac.aa=0;isaac.bb=0;isaac.cc=0;if bf and#bf>=256 then for i=1,256 do isaac.randrsl[i]=bf[i]end else isaac.seed_from_mt()end;for i=1,256 do isaac.mm[i]=0 end;isaac.randinit(true)isaac.isaac()isaac.isaac()end;isaac.getRandom=function()if#isaac.mm>0 then return table.remove(isaac.mm,1)else isaac.generate_isaac()return table.remove(isaac.mm,1)end end;isaac.random=function(bc,bd)if not bd then bd=2^32-1 end;if not bc then bc=0 end;return isaac.getRandom()%bd+bc end;aes={}aes.sbox={[0]=0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}aes.inv_sbox={[0]=0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D}aes.Rcon={[0]=0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,0x6c,0xd8,0xab,0x4d,0x9a,0x2f,0x5e,0xbc,0x63,0xc6,0x97,0x35,0x6a,0xd4,0xb3,0x7d,0xfa,0xef,0xc5,0x91,0x39,0x72,0xe4,0xd3,0xbd,0x61,0xc2,0x9f,0x25,0x4a,0x94,0x33,0x66,0xcc,0x83,0x1d,0x3a,0x74,0xe8,0xcb,0x8d}aes.mul_2={[0]=0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5}aes.mul_3={[0]=0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a}aes.mul_9={[0]=0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46}aes.mul_11={[0]=0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3}aes.mul_13={[0]=0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97}aes.mul_14={[0]=0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d}aes.bxor=bit.bxor;aes.insert=table.insert;aes.copy=function(bg)local w={}for i,s in pairs(bg)do w[i]=s end;return w end;aes.subBytes=function(bg,bh)for i=1,#bg do if not(aes.sbox[bg[i]]and aes.inv_sbox[bg[i]])then error("subBytes: input["..i.."] > 0xFF")end;if bh then bg[i]=aes.inv_sbox[bg[i]]else bg[i]=aes.sbox[bg[i]]end end;return bg end;aes.shiftRows=function(bg)local b8={}b8[1]=bg[1]b8[2]=bg[2]b8[3]=bg[3]b8[4]=bg[4]b8[5]=bg[6]b8[6]=bg[7]b8[7]=bg[8]b8[8]=bg[5]b8[9]=bg[11]b8[10]=bg[12]b8[11]=bg[9]b8[12]=bg[10]b8[13]=bg[16]b8[14]=bg[13]b8[15]=bg[14]b8[16]=bg[15]return b8 end;aes.invShiftRows=function(bg)local b8={}b8[1]=bg[1]b8[2]=bg[2]b8[3]=bg[3]b8[4]=bg[4]b8[5]=bg[8]b8[6]=bg[5]b8[7]=bg[6]b8[8]=bg[7]b8[9]=bg[11]b8[10]=bg[12]b8[11]=bg[9]b8[12]=bg[10]b8[13]=bg[14]b8[14]=bg[15]b8[15]=bg[16]b8[16]=bg[13]return b8 end;aes.finite_field_mul=function(v,b)local bi=0;local bj,bk=v,b;for i=1,8 do if bj==0 or bk==0 then break end;if bit.band(1,bk)>0 then bi=aes.bxor(bi,bj)end;bk=bit.brshift(bk,1)local bl=bit.band(0x80,bj)bj=bit.band(0xFF,bit.blshift(bj,1))if bl>0 then bj=aes.bxor(bj,0x1B)end end;return bi end;aes.mixColumn=function(bm)local bn={}bn[1]=aes.bxor(aes.mul_2[bm[1]],aes.bxor(aes.mul_3[bm[2]],aes.bxor(bm[3],bm[4])))bn[2]=aes.bxor(bm[1],aes.bxor(aes.mul_2[bm[2]],aes.bxor(aes.mul_3[bm[3]],bm[4])))bn[3]=aes.bxor(bm[1],aes.bxor(bm[2],aes.bxor(aes.mul_2[bm[3]],aes.mul_3[bm[4]])))bn[4]=aes.bxor(aes.mul_3[bm[1]],aes.bxor(bm[2],aes.bxor(bm[3],aes.mul_2[bm[4]])))return bn end;aes.invMixColumn=function(bm)local bn={}bn[1]=aes.bxor(aes.mul_14[bm[1]],aes.bxor(aes.mul_11[bm[2]],aes.bxor(aes.mul_13[bm[3]],aes.mul_9[bm[4]])))bn[2]=aes.bxor(aes.mul_9[bm[1]],aes.bxor(aes.mul_14[bm[2]],aes.bxor(aes.mul_11[bm[3]],aes.mul_13[bm[4]])))bn[3]=aes.bxor(aes.mul_13[bm[1]],aes.bxor(aes.mul_9[bm[2]],aes.bxor(aes.mul_14[bm[3]],aes.mul_11[bm[4]])))bn[4]=aes.bxor(aes.mul_11[bm[1]],aes.bxor(aes.mul_13[bm[2]],aes.bxor(aes.mul_9[bm[3]],aes.mul_14[bm[4]])))return bn end;aes.mixColumns=function(bg,bh)local bn={}local bo={bg[1],bg[5],bg[9],bg[13]}local bp={bg[2],bg[6],bg[10],bg[14]}local bq={bg[3],bg[7],bg[11],bg[15]}local br={bg[4],bg[8],bg[12],bg[16]}if bh then bo=aes.invMixColumn(bo)bp=aes.invMixColumn(bp)bq=aes.invMixColumn(bq)br=aes.invMixColumn(br)else bo=aes.mixColumn(bo)bp=aes.mixColumn(bp)bq=aes.mixColumn(bq)br=aes.mixColumn(br)end;bn[1]=bo[1]bn[5]=bo[2]bn[9]=bo[3]bn[13]=bo[4]bn[2]=bp[1]bn[6]=bp[2]bn[10]=bp[3]bn[14]=bp[4]bn[3]=bq[1]bn[7]=bq[2]bn[11]=bq[3]bn[15]=bq[4]bn[4]=br[1]bn[8]=br[2]bn[12]=br[3]bn[16]=br[4]return bn end;aes.addRoundKey=function(bg,bs,bt)local bn={}for i=1,16 do assert(bg[i],"input["..i.."]=nil!")assert(bs[(bt-1)*16+i],"round_key["..(bt-1)*16+i.."]=nil!")bn[i]=aes.bxor(bg[i],bs[(bt-1)*16+i])end;return bn end;aes.key_schedule=function(bu)local function bv(bw,bx,by,bz,i)local u=bx;local bA=by;local bB=bz;local bC=bw;u=aes.bxor(aes.sbox[u],aes.Rcon[i])bA=aes.sbox[bA]bB=aes.sbox[bB]bC=aes.sbox[bC]return u,bA,bB,bC end;local a,b,bD=0,0,0;if#bu<16 then error("Encryption key is too small; key size must be more than 16 bytes.")elseif#bu>=16 and#bu<24 then a=16;b=176 elseif#bu>=24 and#bu<32 then a=24;b=208 else a=32;b=240 end;local bs={}local bE=1;for i=1,a do bs[i]=bu[i]end;while#bs<b do local h=bs[#bs]local j=bs[#bs-1]local bF=bs[#bs-2]local bG=bs[#bs-3]h,j,bF,bG=bv(h,j,bF,bG,bE)bE=bE+1;h=aes.bxor(h,bs[#bs-(a-1)])j=aes.bxor(j,bs[#bs-(a-2)])bF=aes.bxor(bF,bs[#bs-(a-3)])bG=aes.bxor(bG,bs[#bs-(a-4)])aes.insert(bs,h)aes.insert(bs,j)aes.insert(bs,bF)aes.insert(bs,bG)for i=1,3 do h=aes.bxor(bs[#bs],bs[#bs-(a-1)])j=aes.bxor(bs[#bs-1],bs[#bs-(a-2)])bF=aes.bxor(bs[#bs-2],bs[#bs-(a-3)])bG=aes.bxor(bs[#bs-3],bs[#bs-(a-4)])aes.insert(bs,h)aes.insert(bs,j)aes.insert(bs,bF)aes.insert(bs,bG)end;if bD==3 then h=aes.bxor(aes.sbox[bs[#bs]],bs[#bs-(a-1)])j=aes.bxor(aes.sbox[bs[#bs-1]],bs[#bs-(a-2)])bF=aes.bxor(aes.sbox[bs[#bs-2]],bs[#bs-(a-3)])bG=aes.bxor(aes.sbox[bs[#bs-3]],bs[#bs-(a-4)])aes.insert(bs,h)aes.insert(bs,j)aes.insert(bs,bF)aes.insert(bs,bG)end;if bD==2 or bD==3 then local i=2;if bD==3 then i=3 end;for p=1,i do h=aes.bxor(bs[#bs],bs[#bs-(a-1)])j=aes.bxor(bs[#bs-1],bs[#bs-(a-2)])bF=aes.bxor(bs[#bs-2],bs[#bs-(a-3)])bG=aes.bxor(bs[#bs-3],bs[#bs-(a-4)])aes.insert(bs,h)aes.insert(bs,j)aes.insert(bs,bF)aes.insert(bs,bG)end end end;return bs end;aes.breakIntoBlocks=function(l)if type(l)~="string"then error("breakIntoBlocks: data is not a string",2)end;while#l%16~=0 do l=l.."\0"end;local o={}local bH=1;local bn={}for i=1,#l,16 do o[bH]={}for p=1,16 do o[bH][p]=string.byte(l,(bH-1)*16+p,(bH-1)*16+p)end;bH=bH+1 end;return o end;aes.strToBlocks=function(aJ)local bI={}local o={}for i=1,#aJ do bI[i]=string.byte(aJ,i,i)end;for i=1,math.ceil(#bI/16)do o[i]={}for p=1,16 do o[i][p]=bI[(i-1)*16+p]or 0 end end;return o end;aes.encrypt_block=function(l,J)local bs=aes.key_schedule(J)local bJ=l;local bK=0;if#bs==176 then bK=10 elseif#bs==208 then bK=12 elseif#bs==240 then bK=14 else error("encrypt_block: Unknown key size?",2)end;bJ=aes.addRoundKey(bJ,bs,1)for bL=2,bK-1 do bJ=aes.subBytes(bJ)bJ=aes.shiftRows(bJ)bJ=aes.mixColumns(bJ)bJ=aes.addRoundKey(bJ,bs,bL)end;bJ=aes.subBytes(bJ)bJ=aes.shiftRows(bJ)bJ=aes.addRoundKey(bJ,bs,bK)return bJ end;aes.decrypt_block=function(l,J)local bs=aes.key_schedule(J)local bJ=l;local bK=0;if#bs==176 then bK=10 elseif#bs==208 then bK=12 elseif#bs==240 then bK=14 else error("decrypt_block: Unknown key size?",2)end;bJ=aes.addRoundKey(bJ,bs,bK)for bL=bK-1,2,-1 do bJ=aes.invShiftRows(bJ)bJ=aes.subBytes(bJ,true)bJ=aes.addRoundKey(bJ,bs,bL)bJ=aes.mixColumns(bJ,true)end;bJ=aes.invShiftRows(bJ)bJ=aes.subBytes(bJ,true)bJ=aes.addRoundKey(bJ,bs,1)return bJ end;aes.encrypt_block_customExpKey=function(l,bs)local bJ=l;local bK=0;if#bs==176 then bK=10 elseif#bs==208 then bK=12 elseif#bs==240 then bK=14 else error("encrypt_block: Unknown key size?",2)end;bJ=aes.addRoundKey(bJ,bs,1)for bL=2,bK-1 do bJ=aes.subBytes(bJ)bJ=aes.shiftRows(bJ)bJ=aes.mixColumns(bJ)bJ=aes.addRoundKey(bJ,bs,bL)end;bJ=aes.subBytes(bJ)bJ=aes.shiftRows(bJ)bJ=aes.addRoundKey(bJ,bs,bK)return bJ end;aes.decrypt_block_customExpKey=function(l,bs)local bJ=l;local bK=0;if#bs==176 then bK=10 elseif#bs==208 then bK=12 elseif#bs==240 then bK=14 else error("decrypt_block: Unknown key size?",2)end;bJ=aes.addRoundKey(bJ,bs,bK)for bL=bK-1,2,-1 do bJ=aes.invShiftRows(bJ)bJ=aes.subBytes(bJ,true)bJ=aes.addRoundKey(bJ,bs,bL)bJ=aes.mixColumns(bJ,true)end;bJ=aes.invShiftRows(bJ)bJ=aes.subBytes(bJ,true)bJ=aes.addRoundKey(bJ,bs,1)return bJ end;aes.encrypt_bytestream_ecb=function(l,J)local o={}local bM={}local bs=aes.key_schedule(J)for i=1,#l,16 do local T={}for p=1,16 do T[p]=l[i+p-1]or 0 end;T=aes.encrypt_block_customExpKey(T,bs)for p=1,16 do table.insert(bM,T[p])end;os.queueEvent("")os.pullEvent("")end;return bM end;aes.decrypt_bytestream_ecb=function(l,J)local bM={}local bs=aes.key_schedule(J)for i=1,#l,16 do local T={}for p=1,16 do T[p]=l[i+p-1]or 0 end;T=aes.decrypt_block_customExpKey(T,bs)for p=1,16 do table.insert(bM,T[p])end;os.queueEvent("")os.pullEvent("")end;for i=#bM,1,-1 do if bM[i]~=0 then break else bM[i]=nil end end;return bM end;aes.encrypt_bytestream=function(l,J,bN)local o={bN}local bM={}local bs=aes.key_schedule(J)if not bN then error("encrypt_bytestream: No initalization vector was passed.",2)end;for i=1,#l do if l[i]==nil or l[i]>=256 then if type(l[i])=="number"then error("encrypt_bytestream: Invalid data at i="..i.." data[i]="..l[i],2)else error("encrypt_bytestream: Invalid data at i="..i.." data[i]="..type(l[i]),2)end end end;local c=os.clock()for i=1,math.ceil(#l/16)do local T={}if not o[i]then error("encrypt_bytestream: blocks["..i.."] is nil! Input size: "..#l,2)end;for p=1,16 do T[p]=l[(i-1)*16+p]or 0;T[p]=aes.bxor(T[p],o[i][p])end;T=aes.encrypt_block_customExpKey(T,bs)table.insert(o,T)for p=1,16 do aes.insert(bM,T[p])end;if os.clock()-c>=2.5 then os.queueEvent("")os.pullEvent("")c=os.clock()end end;return bM end;aes.decrypt_bytestream=function(l,J,bN)local o={bN}local bM={}local bs=aes.key_schedule(J)if not bN then error("decrypt_bytestream: No initalization vector was passed.",2)end;local c=os.clock()for i=1,math.ceil(#l/16)do local T={}if not o[i]then error("decrypt_bytestream: blocks["..i.."] is nil! Input size: "..#l,2)end;for p=1,16 do T[p]=l[(i-1)*16+p]or 0 end;table.insert(o,T)local bO=aes.decrypt_block_customExpKey(T,bs)for p=1,16 do bO[p]=aes.bxor(bO[p],o[i][p])table.insert(bM,bO[p])end;if os.clock()-c>=2.5 then os.queueEvent("")os.pullEvent("")c=os.clock()end end;for i=#bM,#bM-15,-1 do if bM[i]~=0 then break else bM[i]=nil end end;return bM end;aes.encrypt_str=function(l,J,bP)local bQ={}for i=1,#l do table.insert(bQ,string.byte(l,i,i))end;local bR={}if bP then bR=aes.encrypt_bytestream(bQ,J,bP)else bR=aes.encrypt_bytestream_ecb(bQ,J)end;local bn=""for i=1,#bR do bn=bn..string.char(bR[i])end;return bn end;aes.decrypt_str=function(l,J,bP)local bQ={}for i=1,#l do table.insert(bQ,string.byte(l,i,i))end;local bR={}if bP then bR=aes.decrypt_bytestream(bQ,J,bP)else bR=aes.decrypt_bytestream_ecb(bQ,J)end;local bn=""for i=1,#bR do bn=bn..string.char(bR[i])end;return bn end;aes.davies_meyer=function(l,bS)local bT=bS;for bU=1,16 do for i=1,math.ceil(#l/16)do local T={}for p=1,16 do T[p]=l[(i-1)*16+p]or 0 end;local T=aes.encrypt_block(bT,T)for p=1,16 do T[p]=aes.bxor(T[p],bT[p])end;bT=T;os.queueEvent("")os.pullEvent("")end end;return bT end;aes.increment_ctr=function(bV)local bW={}for i=1,16 do bW[i]=bV[i]or 0 end;bW[1]=bW[1]+incAmt;for i=2,16 do if bW[i-1]<=255 then break end;local bl=bW[i-1]-255;bW[i]=bW[i]+bl end;return bW end;aes.counter_mode_context={key={},ctr={},stream_cache={},set_key=function(self,J)if type(J)=="string"then if#J<16 then error("set_key: Key length ("..#J..") must be at least 16 characters!",2)end;for i=1,16 do self.key[i]=string.byte(J,i,i)end elseif type(J)=="table"then if#J<16 then error("set_key: Key length ("..#J..") must be at least 16 bytes!",2)end;for i=1,16 do if type(J[i])~="number"or J[i]>255 or J[i]<0 then if type(J[i])=="nil"then error("set_key: Value key["..i.."] is invalid: nil",2)else error("set_key: Value key["..i.."] is invalid: "..J[i],2)end end;self.key[i]=J[i]end else error("set_key: Key type is not supported: "..type(J),2)end end,set_ctr=function(self,bX)if type(bX)=="string"then if#bX<16 then error("set_ctr: Counter length ("..#bX..") must be at least 16 characters!",2)end;for i=1,16 do self.ctr[i]=string.byte(bX,i,i)end elseif type(bX)=="table"then if#bX<16 then error("set_ctr: Counter length ("..#bX..") must be at least 16 bytes!",2)end;for i=1,16 do if type(bX[i])~="number"or bX[i]>255 or bX[i]<0 then if type(bX[i])=="nil"then error("set_ctr: Value ctr["..i.."] is invalid: nil",2)else error("set_ctr: Value ctr["..i.."] is invalid: "..bX[i],2)end end;self.ctr[i]=bX[i]end elseif type(bX)=="number"then local bY=bit.band(bX,0xFF)local bZ=bit.band(bit.brshift(bit.band(bX,0xFF00),8),0xFF)local b_=bit.band(bit.brshift(bit.band(bX,0xFF0000),16),0xFF)local c0=bit.band(bit.brshift(bit.band(bX,0xFF000000),24),0xFF)self.ctr={}for i=1,16 do self.ctr[i]=0 end;self.ctr[1]=bY;self.ctr[2]=bZ;self.ctr[3]=b_;self.ctr[4]=c0 else error("set_ctr: Counter type is not supported: "..type(bX),2)end end,generate=function(self,aF)local c1={}if#self.stream_cache>=aF then for i=1,aF do table.insert(c1,table.remove(self.stream_cache))end else for i=1,#self.stream_cache do table.insert(c1,table.remove(self.stream_cache))end;local c2=math.ceil((aF-#c1)/16)for i=1,c2-1 do self.ctr=aes.increment_ctr(self.ctr)local T=aes.encrypt_block(self.ctr,self.key)for i=1,16 do table.insert(c1,T[i])end end;self.ctr=aes.increment_ctr(self.ctr)local T=aes.encrypt_block(self.ctr,self.key)for i=1,aF-#c1 do table.insert(c1,table.remove(T))end;for i=1,#T do table.insert(self.stream_cache,table.remove(T))end end;return c1 end}aes.new_ctrMode=function(J,bP)local c3={stream_cache={},key={},iv={},__index=aes.counter_mode_context}setmetatable(c3,c3)c3:set_key(J)c3:set_ctr(bP)return c3 end;threadAPI={}threadAPI.threads={}threadAPI.starting={}threadAPI.eventFilter=nil;rawset(os,"startThread",function(c4,c5)table.insert(threadAPI.starting,{cr=coroutine.create(c4),blockTerminate=c5 or false,error=nil,dead=false,filter=nil})end)threadAPI.tick=function(H,c6,...)if H.dead then return end;if H.filter~=nil and c6~=H.filter then return end;if c6=="terminate"and H.blockTerminate then return end;coroutine.resume(H.cr,c6,...)H.dead=coroutine.status(H.cr)=="dead"end;threadAPI.tickAll=function()if#threadAPI.starting>0 then local c7=threadAPI.starting;threadAPI.starting={}for aB,s in ipairs(c7)do threadAPI.tick(s)table.insert(threadAPI.threads,s)end end;local y;if threadAPI.eventFilter then y={threadAPI.eventFilter(coroutine.yield())}else y={coroutine.yield()}end;local c8=nil;for Y,s in ipairs(threadAPI.threads)do threadAPI.tick(s,unpack(y))if s.dead then if c8==nil then c8={}end;table.insert(c8,Y-#c8)end end;if c8~=nil then for aB,s in ipairs(c8)do table.remove(threadAPI.threads,s)end end end;rawset(os,"setGlobalEventFilter",function(c4)if threadAPI.eventFilter~=nil then error("This can only be set once!")end;threadAPI.eventFilter=c4;rawset(os,"setGlobalEventFilter",nil)end)threadAPI.startThreading=function(c9)if type(c9)=="function"then os.startThread(c9)else os.startThread(function()shell.run("shell")end)end;while#threadAPI.threads>0 or#threadAPI.starting>0 do threadAPI.tickAll()end;print("All threads terminated!")print("Exiting thread manager")end;DISCOVERY_CHANNEL=65531;local ca=true;local cb=true;local cc="/cryptoNet"local cd={}local ce={}function log(cf)if cb then if term.isColor()then term.write('[')term.setTextColour(colors.blue)term.write('CryptoNet')term.setTextColour(colors.white)print('] '..cf)else print("[CryptoNet] "..cf)end end end;function getLoggingEnabled()return cb end;function setLoggingEnabled(cg)cb=cg end;function getRepeatMessages()return ca end;function setRepeatMessages(ch)ca=ch end;function getWorkingDirectory()return cc end;function setWorkingDirectory(ci)if type(ci)~="string"then error("Directory must be a string.",2)end;cc=ci end;function getAllServers()return cd end;function getAllClientSockets()return ce end;function keyValid(J)if not(type(J)=="table"and#J==16)then return false end;for aB,s in pairs(J)do if type(s)~="number"then return false end end;return true end;function privateKeyValid(J)return type(J)=="table"and type(J.private)=="string"and type(J.shared)=="string"end;function publicKeyValid(J)return type(J)=="table"and type(J.public)=="string"and type(J.shared)=="string"end;function certificateValid(cj,ck)if type(cj)~="table"or type(cj.name)~="string"then return false end;if cj.key==nil and not ck then return false end;if cj.key~=nil and not publicKeyValid(cj.key)then return false end;if cj.key==nil and cj.signature~=nil then return false end;if cj.signature~=nil and type(cj.signature)~="string"then return false end;return true end;function serverValid(server)return type(server)=="table"and type(server.name)=="string"and certificateValid(server.certificate)and privateKeyValid(server.privateKey)and type(server.modemSide)=="string"and type(server.channel)=="number"and type(server.userTable)=="table"and type(server.userTablePath)=="string"and type(server.sockets)=="table"end;function socketValid(cl)return type(cl)=="table"and type(cl.sender)=="string"and type(cl.target)=="string"and keyValid(cl.key)and type(cl.modemSide)=="string"and type(cl.channel)=="number"and type(cl.permissionLevel)=="number"and type(cl.receivedMessages)=="table"end;function userTableValid(cm)if type(cm)~="table"then return false end;for cn,co in pairs(cm)do if type(cn)~="string"or type(co[1])~="table"or type(co[2])~="number"then return false end end;return true end;function resolveModemSide(cp)if cp==nil then for aB,cq in pairs(peripheral.getNames())do if peripheral.getType(cq)=="modem"then cp=cq;break end end;if cp==nil then error("Could not find a modem.",3)end else local found=false;for aB,cq in pairs(redstone.getSides())do if cq==cp then found=true;break end end;if not found then error(tostring(cp).." is not a valid side.",3)end end;if peripheral.getType(cp)~="modem"then error("No modem on side "..cp..".",3)end;log("Using modem "..cp..".")return cp end;function getChannel(cr)local cs=sha256.digest(cr)local ct=cs[1]+cs[2]*2^8;if ct<100 then ct=ct+100 elseif ct>65530 then ct=ct-5 end;return ct end;function channelInUse(ct,cp)for aB,cl in pairs(ce)do if cl.channel==ct and cl.modemSide==cp then return true end end;for aB,server in pairs(cd)do if server.channel==ct and server.modemSide==cp then return true end end;return false end;local function cu(aF)local aJ=""for aB,aH in pairs(aF)do local cv,cw=pcall(string.char,aH)if not cv then return nil end;aJ=aJ..cw end;return aJ end;local function cx(cy)if type(cy)=="nil"then return"x"elseif type(cy)=="boolean"then return cy and"b1"or"b0"elseif type(cy)=="number"then return"n"..tostring(cy)elseif type(cy)=="string"then return"s"..cy elseif type(cy)=="table"then return"t"..textutils.serialize(cy)else error("Can't serialize "..type(cy).."s.",2)end end;local function cz(aJ)local cA=aJ:sub(1,1)local cB=aJ:sub(2)if cA=="x"then return nil elseif cA=="b"then return cB=="1"elseif cA=="n"then return tonumber(cB)elseif cA=="s"then return cB elseif cA=="t"then return textutils.unserialize(cB)else error("Invalid type character: "..cA,2)end end;function serializeCertOrKey(cC)if type(cC)~="table"then error("Can only serialize tables.",2)end;local bn={name=cC.name}if type(cC.public)=="string"then bn.public="\""..cC.public.."\""end;if type(cC.private)=="string"then bn.private="\""..cC.private.."\""end;if type(cC.shared)=="string"then bn.shared="\""..cC.shared.."\""end;if type(cC.key)=="table"then bn.key={}if type(cC.key.public)=="string"then bn.key.public="\""..cC.key.public.."\""end;if type(cC.key.private)=="string"then bn.key.private="\""..cC.key.private.."\""end;if type(cC.key.shared)=="string"then bn.key.shared="\""..cC.key.shared.."\""end end;if type(cC.signature)=="string"then bn.signature="\""..cC.signature.."\""end;return textutils.serialize(bn)end;function deserializeCertOrKey(aJ)if aJ==nil then return nil end;local bn=textutils.unserialize(aJ)if type(bn)~="table"then return bn end;if type(bn.public)=="string"then bn.public=string.gsub(bn.public,"\"","")end;if type(bn.private)=="string"then bn.private=string.gsub(bn.private,"\"","")end;if type(bn.shared)=="string"then bn.shared=string.gsub(bn.shared,"\"","")end;if bn.key~=nil then if type(bn.key.public)=="string"then bn.key.public=string.gsub(bn.key.public,"\"","")end;if type(bn.key.private)=="string"then bn.key.private=string.gsub(bn.key.private,"\"","")end;if type(bn.key.shared)=="string"then bn.key.shared=string.gsub(bn.key.shared,"\"","")end end;if type(bn.signature)=="string"then bn.signature=string.gsub(bn.signature,"\"","")end;return bn end;function generateKey()local bP={}for p=1,4 do local au=isaac.random()for i=0,3 do table.insert(bP,bit.band(bit.brshift(au,8*i),2^8-1))end end;return bP end;function generateCertificate(cD)log("Generating keys... (may take some time)")publicKey,privateKey=rsaKeygen.generateKeyPair()print("")log("Done!")return{name=cD,key=publicKey},privateKey end;function loadCertAuthKey(J)if J==nil then J="certAuth.key"end;if type(J)=="string"then local cE=J;local cF=cc==""and cE or cc.."/"..cE;log("Checking "..cF.." for cert auth key...")if fs.isDir(cF)or not fs.exists(cF)then if fs.isDir(cF)then log(cE.." is not a file, will not be able to verify signatures.")else log(cE.." does not exist, will not be able to verify signatures.")end;return nil else local cG=fs.open(cF,"r")J=deserializeCertOrKey(cG.readAll())cG.close()if not publicKeyValid(J)then log(cE.." does not contain a valid cert auth key, will not be able to verify signatures.")return nil else log("Loaded cert auth key from "..cE..".")return J end end elseif publicKeyValid(J)then return J else log("Invalid cert auth key, won't be able to verify signatures.")return nil end end;function verifyCertificate(cj,J)local cH=sha256.digest(cj.name..cj.key.public..cj.key.shared)local cI=rsaCrypt.bytesToString(rsaCrypt.numberToBytes(rsaCrypt.crypt(J,cj.signature),32*8,8))return tostring(cH)==cI end;local function cJ(cp,ct,cK,cf,cL,cM)local cN=math.random(1,2147483647)local cO={nMessageID=cN,nRecipient=ct,message={message=cf,msgType=cL,target=cK,sender=cM},sProtocol="cryptoNet"}local cP=peripheral.wrap(cp)cP.transmit(ct,ct,cO)if ca then cP.transmit(rednet.CHANNEL_REPEAT,ct,cO)end end;local function cQ(cl,cf)if type(cf)~="string"then error("Message must be a string.",2)end;if not socketValid(cl)then error("Invalid socket.",2)end;local bP=generateKey()local cv,b6=pcall(aes.encrypt_str,cf,cl.key,bP)if cv then cJ(cl.modemSide,cl.channel,cl.target,{{string.byte(b6,1,b6:len())},bP},"encrypted_message",cl.sender)else error("Encryption failed: "..b6:sub(8),2)end end;function send(cl,cf)if not socketValid(cl)then error("Invalid socket.",2)end;cQ(cl,cx(cf))end;function sendUnencrypted(cl,cf)if not socketValid(cl)then error("Invalid socket.",2)end;cJ(cl.modemSide,cl.channel,cl.target,cf,"plain_message",cl.sender)end;function hashPassword(cn,cR,cr)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cR)~="string"then error("Password must be a string.",2)end;if type(cr)~="string"then error("Server name must be a string.",2)end;return tostring(sha256.digest(cr..cn..cR))end;function loadUserTable(cS)if type(cS)~="string"then error("Path must be a string.",2)end;if not fs.exists(cS)then log(cS.." does not exist, creating empty user table.")return{}end;if fs.isDir(cS)then error(cS.." is not a file, could not load user table.",2)end;local cG=fs.open(cS,"r")local cm=textutils.unserialize(cG.readAll())cG.close()if not userTableValid(cm)then error(cS.." does not contain a valid user table, user table could not be loaded.",2)end;log("Loaded user table from "..cS..".")return cm end;function saveUserTable(cm,cS)if type(cS)~="string"then error("Path must be a string.",2)end;if not userTableValid(cm)then error("Not a valid user table",2)end;if fs.isDir(cS)then error(cS.." already exists and is a directory.",2)end;local cG=fs.open(cS,"w")cG.write(textutils.serialize(cm))cG.close()log("Saved user table to "..cS..".")end;function addUserHashed(cn,cT,cU,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cT)~="string"then error("Password hash must be a string.",2)end;if cU==nil then cU=1 elseif type(cU)~="number"then error("Permission level must be a number",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]~=nil then error("User "..cn.." already exists.",2)end;server.userTable[cn]={sha256.pbkdf2(cT,server.name..cn,8),cU}log("Added user "..cn..".")saveUserTable(server.userTable,server.userTablePath)end;function addUser(cn,cR,cU,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cR)~="string"then error("Password must be a string.",2)end;if cU==nil then cU=1 elseif type(cU)~="number"then error("Permission level must be a number",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]~=nil then error("User "..cn.." already exists.",2)end;addUserHashed(cn,hashPassword(cn,cR,server.name),cU,server)end;function deleteUser(cn,server)if type(cn)~="string"then error("Username must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then error("No user called "..cn..".",2)else server.userTable[cn]=nil;log("Deleted user "..cn..".")saveUserTable(server.userTable,server.userTablePath)end end;function userExists(cn,server)if type(cn)~="string"then error("Username must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;return server.userTable[cn]~=nil end;function getPasswordHash(cn,server)if type(cn)~="string"then error("Username must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then return nil end;return server.userTable[cn][1]end;function getPermissionLevel(cn,server)if type(cn)~="string"then error("Username must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then return nil end;return server.userTable[cn][2]end;function setPasswordHashed(cn,cT,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cT)~="string"then error("Password hash must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then error("No user called "..cn..".",2)end;server.userTable[cn][1]=sha256.pbkdf2(cT,server.name..cn,8)log("Updated password for "..cn..".")saveUserTable(server.userTable,server.userTablePath)end;function setPassword(cn,cR,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cR)~="string"then error("Password must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then error("No user called "..cn..".",2)end;setPasswordHashed(cn,hashPassword(cn,cR,server.name),server)end;function setPermissionLevel(cn,cU,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cU)~="number"then error("Permission level must be a number.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then error("No user called "..cn..".",2)end;server.userTable[cn][2]=cU;log("Updated permission level for "..cn..".")saveUserTable(server.userTable,server.userTablePath)end;function checkPasswordHashed(cn,cT,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cT)~="string"then error("Password hash must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;if server.userTable[cn]==nil then return nil end;local cH=sha256.pbkdf2(cT,server.name..cn,8)for i=1,#cH do if cH[i]~=server.userTable[cn][1][i]then return false end end;return true end;function checkPassword(cn,cR,server)if type(cn)~="string"then error("Username must be a string.",2)end;if type(cR)~="string"then error("Password must be a string.",2)end;if server==nil then if#cd==0 then error("No servers running.",2)elseif#cd==1 then server=cd[1]else error("Please specify a server.",2)end elseif not serverValid(server)then error("Invalid server.",2)end;return checkPasswordHashed(cn,hashPassword(cn,cR,server.name),server)end;function loginHashed(cl,cn,cT)if not socketValid(cl)then error("Invalid socket.",2)end;if type(cn)~="string"then error("Username must be a string.",2)end;if type(cT)~="string"then error("Password hash must be a string.",2)end;if cl.server==nil then cQ(cl,"lr"..textutils.serialize({cn,cT}))log("Sent login request for "..cn.." to "..cl.target..".")else if cl.server.userTable[cn]==nil then log("Failed login attempt for "..cn..".")cQ(cl,"lf"..cn)return"login_failed",cn,cl,cl.server else if checkPasswordHashed(cn,cT,cl.server)then cl.username=cn;cl.permissionLevel=math.max(cl.permissionLevel,getPermissionLevel(cn,cl.server))cQ(cl,"ls"..textutils.serialize({cn,cl.permissionLevel}))log(cn.." logged in successfully.")return"login",cn,cl,cl.server else log("Failed login attempt for "..cn..".")cQ(cl,"lf"..cn)return"login_failed",cn,cl,cl.server end end end end;function login(cl,cn,cR)if not socketValid(cl)then error("Invalid socket.",2)end;if type(cn)~="string"then error("Username must be a string.",2)end;if type(cR)~="string"then error("Password must be a string.",2)end;local cr=cl.server==nil and cl.target or cl.sender;return loginHashed(cl,cn,hashPassword(cn,cR,cr))end;function logout(cl)if not socketValid(cl)then error("Invalid socket.",2)end;cQ(cl,"lo")if cl.server==nil then log("Sent logout request to "..cl.target..".")else local cn=cl.username;cl.username=nil;cl.permissionLevel=0;if cn==nil then log("Already logged out.")else log(cn.." logged out.")end;return"logout",cn,cl,server end end;local function cV(cf,cW)local cX={}for cY,cZ in pairs(cW)do if os.clock()-cZ>5 then table.insert(cX,cY)end end;for aB,cY in pairs(cX)do cW[cY]=nil end;if type(cf)=="table"and cf.sProtocol=="cryptoNet"and type(cf.message)=="table"and type(cf.nMessageID)=="number"then if not cW[cf.nMessageID]then cW[cf.nMessageID]=os.clock()return cf.message end;cW[cf.nMessageID]=os.clock()end;return end;function host(cr,c_,d0,cp,cj,privateKey,d1)if type(cr)~="string"then error("Server name must be a string.",2)end;for aB,server in pairs(cd)do if server.name==cr then error("Server called "..cr.." already exists.",2)end end;cp=resolveModemSide(cp)local cP=peripheral.wrap(cp)local d2=type(cj)=="string"and cj or cr..".crt"local cE=type(privateKey)=="string"and privateKey or cr.."_private.key"local d3=cc==""and d2 or cc.."/"..d2;local cF=cc==""and cE or cc.."/"..cE;if type(cj)=="string"then cj=nil end;if type(privateKey)=="string"then privateKey=nil end;if cj~=nil and not certificateValid(cj)then error("Invalid certificate.",2)end;if privateKey~=nil and not privateKeyValid(privateKey)then error("Invalid private key.",2)end;if cj==nil then log("Checking "..d3 .." for certificate...")if fs.isDir(d3)then error(d2 .." already exists and is a directory, not a certificate.",2)elseif fs.exists(d3)then local cG=fs.open(d3,"r")cj=deserializeCertOrKey(cG.readAll())cG.close()if not certificateValid(cj)then error(d2 .." already exists and is not a valid certificate.",2)else log("Loaded certificate from "..d2 ..".")end else log("Certificate file not found, will need to generate a new one.")end end;if privateKey==nil then log("Checking "..cF.." for private key...")if fs.isDir(cF)then error(cE.." already exists and is a directory, not a keyfile.",2)elseif fs.exists(cF)then local cG=fs.open(cF,"r")privateKey=deserializeCertOrKey(cG.readAll())cG.close()if not privateKeyValid(privateKey)then error(cF.." already exists and is not a valid keyfile.",2)else log("Loaded private key from "..cF..".")end else log("Private keyfile not found, will need to generate a new one.")end end;if cj==nil and privateKey==nil then log("No certificate or private key found, generating new ones.")cj,privateKey=generateCertificate(cr)local cG=fs.open(d3,"w")cG.write(serializeCertOrKey(cj))cG.close()log("Saved certificate to "..d3 ..".")cG=fs.open(cF,"w")cG.write(serializeCertOrKey(privateKey))cG.close()log("Saved private key to "..cF..".  Do not share this with anyone!")elseif cj~=nil and privateKey==nil then error("Have a certificate but not a private key, need both or neither.",2)elseif cj==nil and privateKey~=nil then error("Have a private key but not a certificate, need both or neither.",2)end;if cj.signature==nil then log("Warning: Your certificate does not have a signature.")else log("Certificate is signed.")end;local ct=getChannel(cr)cP.open(ct)log("Hosting on channel "..ct..".")if d0 then log("Your server is set to require clients to already have its certificate in order to connect to it.")end;if c_ or c_==nil then cP.open(DISCOVERY_CHANNEL)log("Your server is discoverable.")else log("Your server is not discoverable.")end;if d1==nil then d1=cr.."_users.tbl"end;local cm;if type(d1)=="string"then d1=cc==""and d1 or cc.."/"..d1;cm=loadUserTable(d1)else error("userTablePath must be a string.",2)end;local server={name=cr,certificate=cj,privateKey=privateKey,modemSide=cp,channel=ct,hideCertificate=d0,discoverable=c_ or c_==nil,userTable=cm,userTablePath=d1,sockets={}}table.insert(cd,server)log("Server ready.")return server end;function close(cl)if socketValid(cl)then if not cl.closedRemotely then cQ(cl,"c")end;if cl.server==nil then for i=1,#ce do if ce[i]==cl then table.remove(ce,i)break end end else cl.server.sockets[cl.target]=nil end;if not channelInUse(cl.channel,cl.modemSide)then peripheral.wrap(cl.modemSide).close(cl.channel)log("Closed socket channel "..cl.channel.." on modem "..cl.modemSide..".")end;log("Closed socket.")elseif serverValid(cl)then local server=cl;local d4={}for aB,d5 in pairs(server.sockets)do table.insert(d4,d5)end;for aB,d5 in pairs(d4)do close(d5)end;for i=1,#cd do if cd[i]==server then table.remove(cd,i)break end end;if not channelInUse(server.channel,server.modemSide)then peripheral.wrap(server.modemSide).close(server.channel)log("Closed server channel "..server.channel.." on modem "..server.modemSide..".")end;if server.discoverable then found=false;for aB,d6 in pairs(cd)do if d6.discoverable and d6.modemSide==server.modemSide then found=true;break end end;if not found then peripheral.wrap(server.modemSide).close(DISCOVERY_CHANNEL)log("Closed discovery channel.")end end else error("Must be a valid socket or server.",2)end end;function closeAll()for i=#ce,1,-1 do close(ce[i])end;for i=#cd,1,-1 do close(cd[i])end;log("Closed all sockets and servers.")end;local function d7(cl,cf)local cv=true;local aK=nil;if cf=="c"then log("Connection closed by other end.")cl.closedRemotely=true;close(cl)cl.closedRemotely=nil;aK={"connection_closed",cl,cl.server}elseif cf:sub(1,2)=="lr"then local d8=textutils.unserialize(cf:sub(3))if type(d8)=="table"and type(d8[1])=="string"and type(d8[2])=="string"then aK={loginHashed(cl,d8[1],d8[2])}else cv=false end elseif cf:sub(1,2)=="lf"then log("Failed login attempt for "..cf:sub(3)..".")aK={"login_failed",cf:sub(3),cl,cl.server}elseif cf:sub(1,2)=="ls"then local d9=textutils.unserialize(cf:sub(3))if type(d9)=="table"and type(d9[1])=="string"and type(d9[2])=="number"then cl.username=d9[1]cl.permissionLevel=d9[2]log(cl.username.." logged in successfully.")aK={"login",cl.username,cl,cl.server}else cv=false end elseif cf=="lo"then if cl.server==nil then local cn=cl.username;cl.username=nil;cl.permissionLevel=0;if cn==nil then log("Already logged out.")else log(cn.." logged out.")end;aK={"logout",cn,cl,nil}else aK={logout(cl)}end else cv,cf=pcall(cz,cf)if cv then aK={"encrypted_message",cf,cl,cl.server}end end;return cv,aK end;local function da(server,cf,db)if db==DISCOVERY_CHANNEL and cf.msgType=="discovery_request"and server.discoverable then local cj=server.hideCertificate and{name=server.name}or server.certificate;cJ(server.modemSide,DISCOVERY_CHANNEL,nil,cj,"discovery_response")log("Responded to discovery request.")elseif db==server.channel and cf.target==server.name then if cf.msgType=="certificate_request"and not server.hideCertificate then cJ(server.modemSide,server.channel,nil,server.certificate,"certificate_response")log("Responded to certificate request.")elseif cf.msgType=="connection_request"and type(cf.message)=="string"then local dc=cf.message;if server.sockets[dc]~=nil then log("Received duplicate connection request, ignoring it.")else local cv,dd=pcall(rsaCrypt.crypt,server.privateKey,dc)cv,sessKey=pcall(rsaCrypt.numberToBytes,dd,16*8,8)if cv and(sessKey==nil or#sessKey~=16)then cv=false end;if not cv then log("Received invalid session key.")else local de=tostring(sha256.digest(server.name..server.certificate.key.public..server.certificate.key.shared..dd))local bP=generateKey()de=aes.encrypt_str(de,sessKey,bP)cJ(server.modemSide,server.channel,dc,{{string.byte(de,1,de:len())},bP},"connection_response")log("Responded to connection request.")local cl={sender=server.name,target=dc,key=sessKey,modemSide=server.modemSide,channel=server.channel,server=server,permissionLevel=0,receivedMessages={}}server.sockets[dc]=cl;return{"connection_opened",cl,server}end end elseif cf.msgType=="encrypted_message"and type(cf.message)=="table"and#cf.message==2 and type(cf.message[1])=="table"and type(cf.message[2])=="table"then local cl=server.sockets[cf.sender]local b6=cu(cf.message[1])local bP=cf.message[2]if cl==nil then log("Received a message from a sender who has yet to open a connection.")elseif b6==nil then log("Received invalid message.")elseif cl.receivedMessages[b6]then log("Received duplicate message, ignoring it.")else cl.receivedMessages[b6]=true;local cv,b7=pcall(aes.decrypt_str,b6,cl.key,bP)if cv then local cv,aK=d7(cl,b7)if cv and aK~=null then return aK end end;if not cv then log("Received invalid message.")end end elseif cf.msgType=="plain_message"then local cl=server.sockets[cf.sender]if cl~=nil then return{"plain_message",cf.message,cl,server}else log("Received a message from a sender who has yet to open a connection.")end end end end;local function df(cl,cf,db)if db==cl.channel and cf.sender==cl.target and cf.target==cl.sender then if cf.msgType=="encrypted_message"and type(cf.message)=="table"and#cf.message==2 and type(cf.message[1])=="table"and type(cf.message[2])=="table"then local b6=cu(cf.message[1])local bP=cf.message[2]if b6==nil then log("Received invalid message.")elseif cl.receivedMessages[b6]then log("Received duplicate message, ignoring it.")else cl.receivedMessages[b6]=true;local cv,b7=pcall(aes.decrypt_str,b6,cl.key,bP)if cv then local cv,aK=d7(cl,b7)if cv then return aK end end;if not cv then log("Received invalid message.")end end elseif cf.msgType=="plain_message"then return{"plain_message",cf.message,cl,nil}end end end;local function dg(dh,cW)local cf=cV(dh[5],cW)if cf~=nil then for aB,server in pairs(cd)do local aK=da(server,cf,dh[3])if aK~=nil then return aK end end;for aB,cl in pairs(ce)do local aK=df(cl,cf,dh[3])if aK~=nil then return aK end end end;return nil end;function listen()local cW={}while true do local dh={os.pullEvent("modem_message")}local di=dg(dh,cW)if di~=nil then return table.unpack(di)end end end;function discover(dj,dk,dl,cp)dk=loadCertAuthKey(dk)cp=resolveModemSide(cp)local cP=peripheral.wrap(cp)local dm=cP.isOpen(DISCOVERY_CHANNEL)cP.open(DISCOVERY_CHANNEL)log("Discovering...")cJ(cp,DISCOVERY_CHANNEL,nil,nil,"discovery_request")local cW={}local dn={}local dp=os.startTimer(type(dj)=="number"and dj or 1)while true do local dh={os.pullEvent()}if dh[1]=="modem_message"and dh[3]==DISCOVERY_CHANNEL then local cf=cV(dh[5],cW)if cf~=nil and cf.msgType=="discovery_response"and certificateValid(cf.message,true)then local cj=cf.message;local found=false;for aB,dq in pairs(dn)do if cj.name==dq.name and(cj.key==nil and dq.key==nil or cj.key~=nil and dq.key~=nil and cj.key.public==dq.key.public and cj.key.shared==dq.key.shared)and cj.signature==dq.signature then found=true;break end end;if not found then table.insert(dn,cj)end end elseif dh[1]=="timer"and dh[2]==dp then break end end;if not dm then cP.close(DISCOVERY_CHANNEL)end;if dk~=nil and#dn>0 then log("Checking signatures...")for i=#dn,1,-1 do local cj=dn[i]if cj.signature==nil then if not dl then log("Discarding "..cj.name.." as it has no signature.")table.remove(dn,i)end else local cv,dr=pcall(verifyCertificate,cj,dk)if cv and dr then log(cj.name.." has a valid signature.")else log("Discarding "..cj.name.." as it has an invalid signature.")table.remove(dn,i)end end end end;return dn end;function requestCertificate(cr,dj,dk,dl,cp)if type(cr)~="string"then error("Server name must be a string.",2)end;dk=loadCertAuthKey(dk)cp=resolveModemSide(cp)local cP=peripheral.wrap(cp)local ct=getChannel(cr)local dm=cP.isOpen(ct)cP.open(ct)log("Requesting certificate...")cJ(cp,ct,cr,nil,"certificate_request")local cW={}local dn={}local dp=os.startTimer(type(dj)=="number"and dj or 1)while true do local dh={os.pullEvent()}if dh[1]=="modem_message"and dh[3]==ct then local cf=cV(dh[5],cW)if cf~=nil and cf.msgType=="certificate_response"and certificateValid(cf.message)and cf.message.name==cr then local cj=cf.message;local found=false;for aB,dq in pairs(dn)do if cj.key.public==dq.key.public and cj.key.shared==dq.key.shared and cj.signature==dq.signature then found=true;break end end;if not found then table.insert(dn,cj)end end elseif dh[1]=="timer"and dh[2]==dp then break end end;if not dm then cP.close(ct)end;local ds=0;if dk~=nil and#dn>0 then log("Checking signatures...")for i=#dn,1,-1 do local cj=dn[i]if cj.signature==nil then if not dl then log("Discarding a certificate as it has no signature.")table.remove(dn,i)end else local cv,dr=pcall(verifyCertificate,cj,dk)if cv and dr then log("This certificate has a valid signature.")ds=ds+1 else log("Discarding a certificate as it has an invalid signature.")table.remove(dn,i)end end end end;if#dn==1 then log("One certificate found, good.")return dn[1],dn else if#dn==0 then log("No certificates found.")elseif ds>1 then log("Multiple ("..ds..") certificates had valid signatures, has the certificate authority authorized impersonators?")else log("Multiple ("..#dn..") certificates found, some may be malicious.")end;return nil,dn end end;function connect(cr,dj,dt,cj,cp,dk,dl)if cr~=nil and type(cr)~="string"then error("Server name must be a string or nil.",2)end;if cj==nil then if type(cr)=="string"then cj=cr..".crt"else error("Server name and certificate can't both be nil.",2)end end;if type(cj)=="string"then local d2=cj;local du=cc==""and d2 or cc.."/"..d2;log("Checking "..du.." for certificate...")if fs.isDir(du)or not fs.exists(du)then if fs.isDir(du)then log(d2 .." is not a file, will need to request certificate.")else log(d2 .." does not exist, will need to request certificate.")end;cj=nil else local cG=fs.open(du,"r")cj=deserializeCertOrKey(cG.readAll())cG.close()if not certificateValid(cj)then log(d2 .." does not contain a valid certificate, will need to request certificate.")cj=nil else log("Loaded certificate from "..d2 ..".")end end elseif not certificateValid(cj)then error("Invalid certificate.",2)end;if cr==nil then if cj~=nil then cr=cj.name else error("Failed to load name from certificate, and no name was provided.",2)end end;cp=resolveModemSide(cp)local cP=peripheral.wrap(cp)local ct=getChannel(cr)local dm=cP.isOpen(ct)cP.open(ct)if cj==nil then cj=requestCertificate(cr,dt,dk,dl,cp)if cj==nil then if not dm then cP.close(ct)end;error("Failed to request certificate from server.",2)end end;log("Generating session key...")local sessKey=generateKey()local dd=rsaCrypt.bytesToNumber(sessKey,16*8,8)local dc=rsaCrypt.crypt(cj.key,dd)local dv=tostring(sha256.digest(cr..cj.key.public..cj.key.shared..dd))cJ(cp,ct,cr,dc,"connection_request")log("Awaiting response...")local cW={}local dp=os.startTimer(type(dj)=="number"and dj or 5)while true do local dh={os.pullEvent()}if dh[1]=="modem_message"and dh[3]==ct then local cf=cV(dh[5],cW)if cf~=nil and cf.msgType=="connection_response"and cf.target==dc and type(cf.message)=="table"and#cf.message==2 and type(cf.message[1])=="table"and type(cf.message[2])=="table"then local cv,dw=pcall(aes.decrypt_str,cu(cf.message[1]),sessKey,cf.message[2])if cv and dw==dv then log("Connection successful.")os.cancelTimer(dp)break else log("Received an invalid response.")end end elseif dh[1]=="timer"and dh[2]==dp then if not dm then cP.close(ct)end;error("Did not receive a response before timeout.",2)end end;local cl={sender=dc,target=cr,key=sessKey,modemSide=cp,channel=ct,permissionLevel=0,receivedMessages={}}table.insert(ce,cl)return cl end;local function dx(dy)local cW={}while true do local cv,dz=pcall(function()local dh={os.pullEvent()}if dh[1]=="modem_message"then local di=dg(dh,cW)if di~=nil then os.queueEvent(table.unpack(di))end end;if dy~=nil then os.startThread(function()local cv,dz=pcall(dy,dh)if not cv then if dz=="Terminated"then error("Terminated",0)else print(dz)end end end)end end)if not cv then if dz=="Terminated"then error("Terminated",0)else print(dz)end end end end;function startEventLoop(dA,dy)if dA~=nil and type(dA)~="function"then error("onStart is not a function.",2)end;if dy~=nil and type(dy)~="function"then error("onEvent is not a function.",2)end;threadAPI.startThreading(function()os.startThread(function()dx(dy)end)if dA~=nil then local cv,dz=pcall(dA)if not cv then print(dz)end end end)end;function initCertificateAuthority(dB,dC)if dB==nil then dB="certAuth.key"end;if dC==nil then dC="certAuth_private.key"end;local dD=cc==""and dB or cc.."/"..dB;local dE=cc==""and dC or cc.."/"..dC;if fs.exists(dD)then error(dD.." already exists, please delete both your existing keyfiles in order to generate new ones.",2)end;if fs.exists(dE)then error(dE.." already exists, please delete both your existing keyfiles in order to generate new ones.",2)end;log("Generating key pair... (may take some time)")publicKey,privateKey=rsaKeygen.generateKeyPair()print("")log("Done!")local cG=fs.open(dD,"w")cG.write(serializeCertOrKey(publicKey))cG.close()log("Saved public key to "..dD..".  Give this to client users.")cG=fs.open(dE,"w")cG.write(serializeCertOrKey(privateKey))cG.close()log("Saved private key to "..dE..".  Do not share this with anyone!")log("Initialization successful.")end;function signCertificate(cj,privateKey)local du=nil;if type(cj)=="string"then du=cc==""and cj or cc.."/"..cj;if not fs.exists(du)then error(du.." does not exist.",2)end;if fs.isDir(du)then error(du.." is not a file.",2)end;local cG=fs.open(du,"r")cj=deserializeCertOrKey(cG.readAll())cG.close()if not certificateValid(cj)then error(du.." does not contain a valid certificate.",2)end;log("Loaded certificate from "..du..".")elseif not certificateValid(cj)then error("Not a valid certificate or file.",2)end;if privateKey==nil then privateKey="certAuth_private.key"end;if type(privateKey)=="string"then local cF=cc==""and privateKey or cc.."/"..privateKey;if not fs.exists(cF)then error(cF.." does not exist.",2)end;if fs.isDir(cF)then error(cF.." is not a file.",2)end;local cG=fs.open(cF,"r")privateKey=deserializeCertOrKey(cG.readAll())cG.close()if not privateKeyValid(privateKey)then error(cF.." does not contain a valid private key.",2)end;log("Loaded private key from "..cF..".")elseif not privateKeyValid(privateKey)then error("Not a valid private key or file.",2)end;log("Generating signature...")local cH=sha256.digest(cj.name..cj.key.public..cj.key.shared)cj.signature=rsaCrypt.crypt(privateKey,rsaCrypt.bytesToNumber(cH,32*8,8))if du~=nil then local cG=fs.open(du,"w")cG.write(serializeCertOrKey(cj))cG.close()log("Saved certificate to "..du..".")end;return cj end