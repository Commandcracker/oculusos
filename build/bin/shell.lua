local multishell=multishell;local a=shell;local b=term.current()if multishell then multishell.setTitle(multishell.getCurrent(),"shell")end;local c=a and a.dir()or""local d=a and a.path()or".:/rom/programs"local e=a and a.aliases()or{}local f=a and a.getCompletionInfo()or{}local g=true;local h={}local shell={}local i;if fs.exists("rom/modules/main/cc/require.lua")then i=dofile("rom/modules/main/cc/require.lua").make end;local function j(k)local l={shell=shell,multishell=multishell,supports_scroll=_ENV.supports_scroll}if i then l.require,l.package=i(l,k)end;return l end;local m,n,o;if term.isColour()then m=colours.orange;n=colours.white;o=colours.black else m=colours.white;n=colours.white;o=colours.black end;local p=term.isColour()if _ENV.supports_scroll~=nil then p=_ENV.supports_scroll end;if p then redirect=scroll_window.create(b)end;local function q(r,...)local s=shell.resolveProgram(r)if s~=nil then h[#h+1]=s;if multishell then local t=fs.getName(s)if t:sub(-4)==".lua"then t=t:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),t)end;local u=fs.getDir(s)local l=j(u)l.arg={[0]=r,...}local v=os.run(l,s,...)h[#h]=nil;if multishell then if#h>0 then local t=fs.getName(h[#h])if t:sub(-4)==".lua"then t=t:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),t)else multishell.setTitle(multishell.getCurrent(),"shell")end end;return v else printError("No such program")return false end end;local function w(...)local x=table.concat({...}," ")local y={}local z=false;for A in string.gmatch(x..'"','(.-)"')do if z then table.insert(y,A)else for B in string.gmatch(A,"[^ \t]+")do table.insert(y,B)end end;z=not z end;return y end;function shell.run(...)local y=w(...)local C=y[1]if C then return q(C,table.unpack(y,2))end;return false end;function shell.exit()g=false end;function shell.dir()return c end;function shell.setDir(D)D=fs.combine(D,"")if not fs.isDir(D)then error("Not a directory",2)end;c=D end;function shell.path()return d end;function shell.setPath(E)d=E end;function shell.resolve(F)local G=string.sub(F,1,1)if G=="~"then return fs.combine("/root",string.sub(F,2))end;if G=="/"or G=="\\"then return fs.combine("",F)else return fs.combine(c,F)end end;local function H(F,I)local J=#d;local K=string.sub(F,J,J)if K=="/"or K=="\\"then F=string.sub(F,1,J-1)end;return F.."."..I end;function shell.resolveProgram(L)if e[L]~=nil then L=e[L]end;if L:find("/")or L:find("\\")then local s=shell.resolve(L)if fs.exists(s)and not fs.isDir(s)then return s else local M=H(s,"lua")if fs.exists(M)and not fs.isDir(M)then return M end end;return nil end;for s in string.gmatch(d,"[^:]+")do s=fs.combine(shell.resolve(s),L)if fs.exists(s)and not fs.isDir(s)then return s else local M=H(s,"lua")if fs.exists(M)and not fs.isDir(M)then return M end end end;return nil end;function shell.programs(N)local O={}for s in string.gmatch(d,"[^:]+")do s=shell.resolve(s)if fs.isDir(s)then local P=fs.list(s)for Q=1,#P do local R=P[Q]if not fs.isDir(fs.combine(s,R))and(N or string.sub(R,1,1)~=".")then if#R>4 and R:sub(-4)==".lua"then R=R:sub(1,-5)end;O[R]=true end end end end;local S={}for T in pairs(O)do table.insert(S,T)end;table.sort(S)return S end;local function U(x)if#x>0 and string.sub(x,1,1)=="/"then return fs.complete(x,"",true,false)else local V={}local W={}for X,C in pairs(e)do if#X>#x and string.sub(X,1,#x)==x then local Y=string.sub(X,#x+1)if not W[Y]then table.insert(V,Y)W[Y]=true end end end;local Z=shell.programs()for Q=1,#Z do local _=Z[Q]if#_>#x and string.sub(_,1,#x)==x then local Y=string.sub(_,#x+1)if not W[Y]then table.insert(V,Y)W[Y]=true end end end;table.sort(V)return V end end;local function a0(_,a1,a2,a3)local a4=f[_]if a4 then return a4.fnComplete(shell,a1,a2,a3)end;return nil end;function shell.complete(x)if#x>0 then local y=w(x)local a5=#y;if string.sub(x,#x,#x)==" "then a5=a5+1 end;if a5==1 then local a6=y[1]or""local s=shell.resolveProgram(a6)if f[s]then return{" "}else local V=U(a6)for Q=1,#V do local Y=V[Q]local s=shell.resolveProgram(a6 ..Y)if f[s]then V[Q]=Y.." "end end;return V end elseif a5>1 then local s=shell.resolveProgram(y[1])local a2=y[a5]or""local a3=y;a3[a5]=nil;return a0(s,a5-1,a2,a3)end end;return nil end;function shell.completeProgram(_)return U(_)end;function shell.setCompletionFunction(_,a7)f[_]={fnComplete=a7}end;function shell.getCompletionInfo()return f end;function shell.getRunningProgram()if#h>0 then return h[#h]end;return nil end;function shell.setAlias(r,a8)e[r]=a8 end;function shell.clearAlias(r)e[r]=nil end;function shell.aliases()local a9={}for X,C in pairs(e)do a9[X]=C end;return a9 end;if multishell then function shell.openTab(...)local y=w(...)local C=y[1]if C then local s=shell.resolveProgram(C)if s=="rom/programs/shell"or s=="bin/shell"then return multishell.launch(j("rom/programs"),"bin/shell",table.unpack(y,2))elseif s~=nil then return multishell.launch(j("rom/programs"),"bin/shell",C,table.unpack(y,2))else printError("No such program")end end end;function shell.switchTab(aa)multishell.setFocus(aa)end end;local ab={...}if#ab>0 then shell.run(...)return end;local ac={}do local ad=".shell_history"if ad and fs.exists(ad)then local ae=fs.open(ad,"r")if ae then for af in ae.readLine do ac[#ac+1]=af end;ae.close()end end;local ag=1e4;if#ac>ag then while#ac>ag do table.remove(ac,1)end;local ad=".shell_history"if ad then local ae=fs.open(ad,"w")if ae then for ah=1,#ac do ae.writeLine(ac[ah])end;ae.close()end end end end;local function ai()if fs.exists("startup.lua")and not fs.isDir("startup.lua")then return"startup.lua"end;if fs.isDir("startup")then local aj=fs.list("startup")[1]if aj then return fs.combine("startup",aj)end end;return nil end;local ak=0;local function al(am)local an=http.get(am)if an then local ao=an.readAll()an.close()return ao else return nil end end;local function ap(aq)if fs.exists(aq)then local ar=io.open(aq,"r")local x=ar:read()ar:close()return x end end;local function as()if http then local at=json.decode(ap("/.system_info"))local au=al("https://api.github.com/repos/"..at.git.owner.."/"..at.git.repo.."/compare/master..."..at.git.commit)if au~=nil then au=json.decode(au)if au~=nil and au.message==nil and au.behind_by>0 then print("Your OculusOS is outdated by "..au.behind_by.." commits! Get the latest release bye typing 'do-release-upgrade'.")end end end end;local av={PS1="&b(&e\\h&b)-[&0\\w&b]\n&e# "}local aw;if fs.exists("/.shellrc")then aw=dofile("/.shellrc")end;local ax=false;local ay=coroutine.create(function()if p then term.redirect(redirect)term.setCursorPos(1,1)else term.redirect(b)end;term.setBackgroundColor(o)as()if not fs.exists("/.passwd")then print("No Password has been set. This is a security risk - please type 'passwd' to set a password.")end;term.setTextColour(m)write("OculusOS")term.setTextColour(n)while g do if p then local az=1e3;if az then redirect.setMaxScrollback(az)end end;term.setBackgroundColor(o)term.setTextColour(m)if term.getCursorPos()~=1 then print()end;local aA=os.getComputerLabel()if not aA then aA="computer_"..os.getComputerID()end;local aB;if aw and aw.PS1 then aB=aw.PS1 else aB=av.PS1 end;local k=shell.dir()if string.sub(k,1,4)=="root"then k="~"..string.sub(k,5)else k="/"..k end;aB=aB:gsub("\\w",k)if os.date then aB=aB:gsub("\\t",os.date("%H:%M:%S"))aB=aB:gsub("\\T",os.date("%I:%M:%S"))aB=aB:gsub("\\d",os.date("%a %b %y"))aB=aB:gsub("\\@",os.date("%I:%M %p"))aB=aB:gsub("\\A",os.date("%H:%M"))end;cprint.cwrite(aB:gsub("\\h",aA))if p then redirect.setCursorPos(term.getCursorPos())end;term.setTextColour(n)local af;if settings then if settings.get("shell.autocomplete")then af=read(nil,ac,shell.complete)else af=read(nil,ac)end else af=read(nil,ac,shell.complete)end;if not af then break end;if p then local aC,aD=term.getCursorPos()redirect.setCursorThreshold(aD)end;local aE=true;if string.find(af,"!!")then if#ac==0 then printError("No Command History!")else print(ac[#ac])af=af:gsub("!!",ac[#ac])end end;if#ac==0 and string.find(af,"!!")then else if af:match("%S")and ac[#ac]~=af then ac[#ac+1]=af;local ad=".shell_history"if ad then local ae=fs.open(ad,"a")ae.writeLine(af)ae.close()end end;for aC,L in ipairs(oculusos.split(af,";"))do ax=true;aE=shell.run(L)ax=false end end;if p then term.redirect(redirect)redirect.endPrivateMode(not aE)redirect.draw(0)end end;if p then term.redirect(b)end end)local aE,aF=coroutine.resume(ay)if p then while coroutine.status(ay)~="dead"do local aG=table.pack(coroutine.yield())local aH=aG[1]if aF==nil or aH==aF or aH=="terminate"then aE,aF=coroutine.resume(ay,table.unpack(aG,1))end;if aH=="term_resize"then redirect.updateSize()redirect.draw(ak or 0,true)end;if not ax or redirect.getCursorBlink and redirect.getCursorBlink()then local aI=0;if aH=="mouse_scroll"then aI=aG[2]elseif aH=="key"and aG[2]==keys.pageDown then aI=10 elseif aH=="key"and aG[2]==keys.pageUp then aI=-10 elseif aH=="key"or aH=="paste"then aI=-ak end;if aI~=0 and term.current()==redirect and not redirect.isPrivateMode()then ak=ak+aI;if ak>0 then ak=0 end;if ak<-redirect.getTotalHeight()then ak=-redirect.getTotalHeight()end;redirect.draw(ak)end end end else while coroutine.status(ay)~="dead"do local aG=table.pack(coroutine.yield())local aH=aG[1]if aF==nil or aH==aF or aH=="terminate"then aE,aF=coroutine.resume(ay,table.unpack(aG,1))end end end;if not aE then error(aF,0)end