local multishell=multishell;local a=shell;local b=term.current()local c=scroll_window.create(b)if multishell then multishell.setTitle(multishell.getCurrent(),"shell")end;local d=a and a.dir()or""local e=a and a.path()or".:/rom/programs"local f=a and a.aliases()or{}local g=a and a.getCompletionInfo()or{}local h=true;local i={}local shell={}local j={["shell"]=shell,["multishell"]=multishell}local k,l,m;if term.isColour()then k=colours.orange;l=colours.white;m=colours.black else k=colours.white;l=colours.white;m=colours.black end;local function n(o,...)local p=shell.resolveProgram(o)if p~=nil then i[#i+1]=p;if multishell then local q=fs.getName(p)if q:sub(-4)==".lua"then q=q:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),q)end;local r=os.run(j,p,...)i[#i]=nil;if multishell then if#i>0 then local q=fs.getName(i[#i])if q:sub(-4)==".lua"then q=q:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),q)else multishell.setTitle(multishell.getCurrent(),"shell")end end;return r else printError("No such program")return false end end;local function s(...)local t=table.concat({...}," ")local u={}local v=false;for w in string.gmatch(t..'"','(.-)"')do if v then table.insert(u,w)else for x in string.gmatch(w,"[^ \t]+")do table.insert(u,x)end end;v=not v end;return u end;function shell.run(...)local u=s(...)local y=u[1]if y then return n(y,table.unpack(u,2))end;return false end;function shell.exit()h=false end;function shell.dir()return d end;function shell.setDir(z)z=fs.combine(z,"")if not fs.isDir(z)then error("Not a directory",2)end;d=z end;function shell.path()return e end;function shell.setPath(A)e=A end;function shell.resolve(B)local C=string.sub(B,1,1)if C=="/"or C=="\\"then return fs.combine("",B)else return fs.combine(d,B)end end;local function D(B,E)local F=#e;local G=string.sub(B,F,F)if G=="/"or G=="\\"then B=string.sub(B,1,F-1)end;return B.."."..E end;function shell.resolveProgram(H)if f[H]~=nil then H=f[H]end;if H:find("/")or H:find("\\")then local p=shell.resolve(H)if fs.exists(p)and not fs.isDir(p)then return p else local I=D(p,"lua")if fs.exists(I)and not fs.isDir(I)then return I end end;return nil end;for p in string.gmatch(e,"[^:]+")do p=fs.combine(shell.resolve(p),H)if fs.exists(p)and not fs.isDir(p)then return p else local I=D(p,"lua")if fs.exists(I)and not fs.isDir(I)then return I end end end;return nil end;function shell.programs(J)local K={}for p in string.gmatch(e,"[^:]+")do p=shell.resolve(p)if fs.isDir(p)then local L=fs.list(p)for M=1,#L do local N=L[M]if not fs.isDir(fs.combine(p,N))and(J or string.sub(N,1,1)~=".")then if#N>4 and N:sub(-4)==".lua"then N=N:sub(1,-5)end;K[N]=true end end end end;local O={}for P in pairs(K)do table.insert(O,P)end;table.sort(O)return O end;local function Q(t)if#t>0 and string.sub(t,1,1)=="/"then return fs.complete(t,"",true,false)else local R={}local S={}for T,y in pairs(f)do if#T>#t and string.sub(T,1,#t)==t then local U=string.sub(T,#t+1)if not S[U]then table.insert(R,U)S[U]=true end end end;local V=shell.programs()for M=1,#V do local W=V[M]if#W>#t and string.sub(W,1,#t)==t then local U=string.sub(W,#t+1)if not S[U]then table.insert(R,U)S[U]=true end end end;table.sort(R)return R end end;local function X(W,Y,Z,_)local a0=g[W]if a0 then return a0.fnComplete(shell,Y,Z,_)end;return nil end;function shell.complete(t)if#t>0 then local u=s(t)local a1=#u;if string.sub(t,#t,#t)==" "then a1=a1+1 end;if a1==1 then local a2=u[1]or""local p=shell.resolveProgram(a2)if g[p]then return{" "}else local R=Q(a2)for M=1,#R do local U=R[M]local p=shell.resolveProgram(a2 ..U)if g[p]then R[M]=U.." "end end;return R end elseif a1>1 then local p=shell.resolveProgram(u[1])local Z=u[a1]or""local _=u;_[a1]=nil;return X(p,a1-1,Z,_)end end;return nil end;function shell.completeProgram(W)return Q(W)end;function shell.setCompletionFunction(W,a3)g[W]={fnComplete=a3}end;function shell.getCompletionInfo()return g end;function shell.getRunningProgram()if#i>0 then return i[#i]end;return nil end;function shell.setAlias(o,a4)f[o]=a4 end;function shell.clearAlias(o)f[o]=nil end;function shell.aliases()local a5={}for T,y in pairs(f)do a5[T]=y end;return a5 end;if multishell then function shell.openTab(...)local u=s(...)local y=u[1]if y then local p=shell.resolveProgram(y)if p=="rom/programs/shell"then return multishell.launch(j,p,table.unpack(u,2))elseif p~=nil then return multishell.launch(j,"rom/programs/shell",y,table.unpack(u,2))else printError("No such program")end end end;function shell.switchTab(a6)multishell.setFocus(a6)end end;local a7={...}if#a7>0 then shell.run(...)return end;local a8={}do local a9=".shell_history"if a9 and fs.exists(a9)then local aa=fs.open(a9,"r")if aa then for ab in aa.readLine do a8[#a8+1]=ab end;aa.close()end end;local ac=1e4;if#a8>ac then while#a8>ac do table.remove(a8,1)end;local a9=".shell_history"if a9 then local aa=fs.open(a9,"w")if aa then for ad=1,#a8 do aa.writeLine(a8[ad])end;aa.close()end end end end;local function ae()if fs.exists("startup.lua")and not fs.isDir("startup.lua")then return"startup.lua"end;if fs.isDir("startup")then local af=fs.list("startup")[1]if af then return fs.combine("startup",af)end end;return nil end;local ag=0;local function ah(ai)local aj=http.get(ai)if aj then local ak=aj.readAll()aj.close()return ak else return nil end end;local function al(am)if fs.exists(am)then local an=io.open(am,"r")local t=an:read()an:close()return t end end;local function ao()if http then local ap=json.decode(al("/.system_info"))local aq=ah("https://api.github.com/repos/"..ap.git.owner.."/"..ap.git.repo.."/git/refs/heads/"..ap.git.branch)if aq==nil then else local ar=json.decode(aq).object.sha;local as=ap.git.commit;if as==ar then else term.write("Your OculusOS is outdated by ")aq=ah("https://api.github.com/repos/"..ap.git.owner.."/"..ap.git.repo.."/compare/"..ar.."..."..as)if aq==nil then term.write("?")else term.write(json.decode(aq).behind_by)end;print(" commits! Get the latest release bye typing 'do-release-upgrade'.")end end end end;local at=coroutine.create(function()term.redirect(c)term.setCursorPos(1,1)term.setBackgroundColor(m)ao()if not fs.exists("/.passwd")then print("No Password has been set. This is a security risk - please type 'passwd' to set a password.")end;term.setTextColour(k)print("OculusOS")term.setTextColour(l)while h do local au=1e3;if au then c.setMaxScrollback(au)end;term.setBackgroundColor(m)term.setTextColour(k)if term.getCursorPos()~=1 then print()end;local av=os.getComputerLabel()if not av then av="oculusos"end;if PS1 then local aw=PS1:gsub("\w",'/'..shell.dir())cprint.cwrite(aw:gsub("\h",av))else write(shell.dir().."> ")end;term.setTextColour(l)local ab;if settings then if settings.get("shell.autocomplete")then ab=read(nil,a8,shell.complete)else ab=read(nil,a8)end else ab=read(nil,a8,shell.complete)end;if not ab then break end;local ax,ay=term.getCursorPos()c.setCursorThreshold(ay)if string.find(ab,"!!")then if#a8==0 then printError("No Command History!")else print(a8[#a8])ab=ab:gsub("!!",a8[#a8])end end;if#a8==0 and string.find(ab,"!!")then else if ab:match("%S")and a8[#a8]~=ab then a8[#a8+1]=ab;local a9=".shell_history"if a9 then local aa=fs.open(a9,"a")aa.writeLine(ab)aa.close()end end;for ax,H in ipairs(oculusos.split(ab,";"))do shell.run(H)end end end end)local az,aA=coroutine.resume(at)while coroutine.status(at)~="dead"do local aB=table.pack(coroutine.yield())local aC=aB[1]if aA==nil or aC==aA or aC=="terminate"then az,aA=coroutine.resume(at,table.unpack(aB,1))end;if aC=="term_resize"then c.updateSize()c.draw(ag or 0,true)end;if c.getCursorBlink()then local aD=0;if aC=="mouse_scroll"then aD=aB[2]elseif aC=="key"and aB[2]==keys.pageDown then aD=10 elseif aC=="key"and aB[2]==keys.pageUp then aD=-10 elseif aC=="key"or aC=="paste"then aD=-ag end;if aD~=0 and term.current()==c and not c.isPrivateMode()then ag=ag+aD;if ag>0 then ag=0 end;if ag<-c.getTotalHeight()then ag=-c.getTotalHeight()end;c.draw(ag)end end end;if not az then error(aA,0)end