local multishell=multishell;local a=shell;local b=term.current()if multishell then multishell.setTitle(multishell.getCurrent(),"shell")end;local c=a and a.dir()or""local d=a and a.path()or".:/rom/programs"local e=a and a.aliases()or{}local f=a and a.getCompletionInfo()or{}local g=true;local h={}local shell={}local i={["shell"]=shell,["multishell"]=multishell,["supports_scroll"]=_ENV.supports_scroll}local j,k,l;if term.isColour()then j=colours.orange;k=colours.white;l=colours.black else j=colours.white;k=colours.white;l=colours.black end;local m=term.isColour()if _ENV.supports_scroll~=nil then m=_ENV.supports_scroll end;if m then redirect=scroll_window.create(b)end;local function n(o,...)local p=shell.resolveProgram(o)if p~=nil then h[#h+1]=p;if multishell then local q=fs.getName(p)if q:sub(-4)==".lua"then q=q:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),q)end;local r=os.run(i,p,...)h[#h]=nil;if multishell then if#h>0 then local q=fs.getName(h[#h])if q:sub(-4)==".lua"then q=q:sub(1,-5)end;multishell.setTitle(multishell.getCurrent(),q)else multishell.setTitle(multishell.getCurrent(),"shell")end end;return r else printError("No such program")return false end end;local function s(...)local t=table.concat({...}," ")local u={}local v=false;for w in string.gmatch(t..'"','(.-)"')do if v then table.insert(u,w)else for x in string.gmatch(w,"[^ \t]+")do table.insert(u,x)end end;v=not v end;return u end;function shell.run(...)local u=s(...)local y=u[1]if y then return n(y,table.unpack(u,2))end;return false end;function shell.exit()g=false end;function shell.dir()return c end;function shell.setDir(z)z=fs.combine(z,"")if not fs.isDir(z)then error("Not a directory",2)end;c=z end;function shell.path()return d end;function shell.setPath(A)d=A end;function shell.resolve(B)local C=string.sub(B,1,1)if C=="/"or C=="\\"then return fs.combine("",B)else return fs.combine(c,B)end end;local function D(B,E)local F=#d;local G=string.sub(B,F,F)if G=="/"or G=="\\"then B=string.sub(B,1,F-1)end;return B.."."..E end;function shell.resolveProgram(H)if e[H]~=nil then H=e[H]end;if H:find("/")or H:find("\\")then local p=shell.resolve(H)if fs.exists(p)and not fs.isDir(p)then return p else local I=D(p,"lua")if fs.exists(I)and not fs.isDir(I)then return I end end;return nil end;for p in string.gmatch(d,"[^:]+")do p=fs.combine(shell.resolve(p),H)if fs.exists(p)and not fs.isDir(p)then return p else local I=D(p,"lua")if fs.exists(I)and not fs.isDir(I)then return I end end end;return nil end;function shell.programs(J)local K={}for p in string.gmatch(d,"[^:]+")do p=shell.resolve(p)if fs.isDir(p)then local L=fs.list(p)for M=1,#L do local N=L[M]if not fs.isDir(fs.combine(p,N))and(J or string.sub(N,1,1)~=".")then if#N>4 and N:sub(-4)==".lua"then N=N:sub(1,-5)end;K[N]=true end end end end;local O={}for P in pairs(K)do table.insert(O,P)end;table.sort(O)return O end;local function Q(t)if#t>0 and string.sub(t,1,1)=="/"then return fs.complete(t,"",true,false)else local R={}local S={}for T,y in pairs(e)do if#T>#t and string.sub(T,1,#t)==t then local U=string.sub(T,#t+1)if not S[U]then table.insert(R,U)S[U]=true end end end;local V=shell.programs()for M=1,#V do local W=V[M]if#W>#t and string.sub(W,1,#t)==t then local U=string.sub(W,#t+1)if not S[U]then table.insert(R,U)S[U]=true end end end;table.sort(R)return R end end;local function X(W,Y,Z,_)local a0=f[W]if a0 then return a0.fnComplete(shell,Y,Z,_)end;return nil end;function shell.complete(t)if#t>0 then local u=s(t)local a1=#u;if string.sub(t,#t,#t)==" "then a1=a1+1 end;if a1==1 then local a2=u[1]or""local p=shell.resolveProgram(a2)if f[p]then return{" "}else local R=Q(a2)for M=1,#R do local U=R[M]local p=shell.resolveProgram(a2 ..U)if f[p]then R[M]=U.." "end end;return R end elseif a1>1 then local p=shell.resolveProgram(u[1])local Z=u[a1]or""local _=u;_[a1]=nil;return X(p,a1-1,Z,_)end end;return nil end;function shell.completeProgram(W)return Q(W)end;function shell.setCompletionFunction(W,a3)f[W]={fnComplete=a3}end;function shell.getCompletionInfo()return f end;function shell.getRunningProgram()if#h>0 then return h[#h]end;return nil end;function shell.setAlias(o,a4)e[o]=a4 end;function shell.clearAlias(o)e[o]=nil end;function shell.aliases()local a5={}for T,y in pairs(e)do a5[T]=y end;return a5 end;if multishell then function shell.openTab(...)local u=s(...)local y=u[1]if y then local p=shell.resolveProgram(y)if p=="rom/programs/shell"then return multishell.launch(i,p,table.unpack(u,2))elseif p~=nil then return multishell.launch(i,"rom/programs/shell",y,table.unpack(u,2))else printError("No such program")end end end;function shell.switchTab(a6)multishell.setFocus(a6)end end;local a7={...}if#a7>0 then shell.run(...)return end;local a8={}do local a9=".shell_history"if a9 and fs.exists(a9)then local aa=fs.open(a9,"r")if aa then for ab in aa.readLine do a8[#a8+1]=ab end;aa.close()end end;local ac=1e4;if#a8>ac then while#a8>ac do table.remove(a8,1)end;local a9=".shell_history"if a9 then local aa=fs.open(a9,"w")if aa then for ad=1,#a8 do aa.writeLine(a8[ad])end;aa.close()end end end end;local function ae()if fs.exists("startup.lua")and not fs.isDir("startup.lua")then return"startup.lua"end;if fs.isDir("startup")then local af=fs.list("startup")[1]if af then return fs.combine("startup",af)end end;return nil end;local ag=0;local function ah(ai)local aj=http.get(ai)if aj then local ak=aj.readAll()aj.close()return ak else return nil end end;local function al(am)if fs.exists(am)then local an=io.open(am,"r")local t=an:read()an:close()return t end end;local function ao()if http then local ap=json.decode(al("/.system_info"))local aq=ah("https://api.github.com/repos/"..ap.git.owner.."/"..ap.git.repo.."/git/refs/heads/"..ap.git.branch)if aq==nil then else local ar=json.decode(aq).object.sha;local as=ap.git.commit;if as==ar then else term.write("Your OculusOS is outdated by ")aq=ah("https://api.github.com/repos/"..ap.git.owner.."/"..ap.git.repo.."/compare/"..ar.."..."..as)if aq==nil then term.write("?")else term.write(json.decode(aq).behind_by)end;print(" commits! Get the latest release bye typing 'do-release-upgrade'.")end end end end;local at={PS1="&b(&e\\h&b)-[&0\\w&b]\n&e# "}local au;if fs.exists("/.shellrc")then au=dofile("/.shellrc")end;local av=false;local aw=coroutine.create(function()if m then term.redirect(redirect)term.setCursorPos(1,1)else term.redirect(b)end;term.setBackgroundColor(l)ao()if not fs.exists("/.passwd")then print("No Password has been set. This is a security risk - please type 'passwd' to set a password.")end;term.setTextColour(j)write("OculusOS")term.setTextColour(k)while g do if m then local ax=1e3;if ax then redirect.setMaxScrollback(ax)end end;term.setBackgroundColor(l)term.setTextColour(j)if term.getCursorPos()~=1 then print()end;local ay=os.getComputerLabel()if not ay then ay="oculusos"end;local az;if au and au.PS1 then az=au.PS1 else az=at.PS1 end;az=az:gsub("\\w",'/'..shell.dir())if os.date then az=az:gsub("\\t",os.date("%H:%M:%S"))az=az:gsub("\\T",os.date("%I:%M:%S"))az=az:gsub("\\d",os.date("%a %b %y"))az=az:gsub("\\@",os.date("%I:%M %p"))az=az:gsub("\\A",os.date("%H:%M"))end;cprint.cwrite(az:gsub("\\h",ay))if m then redirect.setCursorPos(term.getCursorPos())end;term.setTextColour(k)local ab;if settings then if settings.get("shell.autocomplete")then ab=read(nil,a8,shell.complete)else ab=read(nil,a8)end else ab=read(nil,a8,shell.complete)end;if not ab then break end;if m then local aA,aB=term.getCursorPos()redirect.setCursorThreshold(aB)end;local aC=true;if string.find(ab,"!!")then if#a8==0 then printError("No Command History!")else print(a8[#a8])ab=ab:gsub("!!",a8[#a8])end end;if#a8==0 and string.find(ab,"!!")then else if ab:match("%S")and a8[#a8]~=ab then a8[#a8+1]=ab;local a9=".shell_history"if a9 then local aa=fs.open(a9,"a")aa.writeLine(ab)aa.close()end end;for aA,H in ipairs(oculusos.split(ab,";"))do av=true;aC=shell.run(H)av=false end end;if m then term.redirect(redirect)redirect.endPrivateMode(not aC)redirect.draw(0)end end;if m then term.redirect(b)end end)local aC,aD=coroutine.resume(aw)if m then while coroutine.status(aw)~="dead"do local aE=table.pack(coroutine.yield())local aF=aE[1]if aD==nil or aF==aD or aF=="terminate"then aC,aD=coroutine.resume(aw,table.unpack(aE,1))end;if aF=="term_resize"then redirect.updateSize()redirect.draw(ag or 0,true)end;if not av then local aG=0;if aF=="mouse_scroll"then aG=aE[2]elseif aF=="key"and aE[2]==keys.pageDown then aG=10 elseif aF=="key"and aE[2]==keys.pageUp then aG=-10 elseif aF=="key"or aF=="paste"then aG=-ag end;if aG~=0 and term.current()==redirect and not redirect.isPrivateMode()then ag=ag+aG;if ag>0 then ag=0 end;if ag<-redirect.getTotalHeight()then ag=-redirect.getTotalHeight()end;redirect.draw(ag)end end end else while coroutine.status(aw)~="dead"do local aE=table.pack(coroutine.yield())local aF=aE[1]if aD==nil or aF==aD or aF=="terminate"then aC,aD=coroutine.resume(aw,table.unpack(aE,1))end end end;if not aC then error(aD,0)end